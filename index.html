<!DOCTYPE html>
<html lang="en">
<head>
    <!-- ðŸ”´ REGION: SEO -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <title>Hall Family Reunion Tracker</title>
    <meta name="description" content="The Hall Family Reunion - Track attendees, share messages, and suggest activities!">

    <!-- Tailwind CSS via CDN -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Animate.css for animations -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />

    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- ðŸ”´ END REGION: SEO -->

    <!-- Dark mode styles -->
    <style>
        /* Dark mode styles */
        .dark-mode {
            background-color: #121212;
            color: #e0e0e0;
        }

        .dark-mode .family-card {
            background-color: #1e1e1e;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .dark-mode .card-header {
            background-color: #333;
        }

        .dark-mode .form-input {
            background-color: #2d2d2d;
            color: #e0e0e0;
            border-color: #444;
        }

        .dark-mode .message-board {
            background-color: #1a1a1a;
            border-color: #333;
        }

        .dark-mode .message-item {
            border-color: #333;
        }

        .dark-mode .message-item:hover {
            background-color: #252525;
        }

        .dark-mode .message-content {
            color: #e0e0e0;
        }

        /* Toggle switch */
        .theme-switch {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #7a52c7;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }
    </style>

    <!-- ðŸ”µ REGION: UI STYLES -->
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f3f0f7;
        }

        .family-card {
            transition: all 0.2s ease;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(124, 58, 237, 0.15);
            overflow: hidden;
        }

        .family-card:hover {
            box-shadow: 0 6px 15px rgba(124, 58, 237, 0.25);
        }

        .card-header {
            background-color: #9370DB;
            color: white;
            padding: 15px;
            font-size: 1.5rem;
            font-weight: 600;
            text-align: center;
        }

        .card-body {
            padding: 20px;
        }

        .balloon {
            position: absolute;
            width: 35px;
            height: 45px;
            background-color: #9370DB;
            border-radius: 50%;
            animation: float 12s ease-in-out infinite;
            z-index: 1;
            opacity: 0.7;
        }

        .balloon::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 15px;
            background-color: #b19cd9;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
        }

        @keyframes float {
            0% { transform: translate(0, 0); }
            25% { transform: translate(5px, -8px); } /* Reduced movement */
            50% { transform: translate(8px, 0); } /* Reduced movement */
            75% { transform: translate(-5px, -5px); } /* Reduced movement */
            100% { transform: translate(0, 0); }
        }

        .balloon-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 0;
        }

        /* Fireworks animation */
        .firework {
            position: absolute;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            box-shadow: 0 0 10px 5px rgba(255, 255, 255, 0.8);
            animation: explode 1s ease-out forwards;
            opacity: 0;
        }

        @keyframes explode {
            0% {
                transform: scale(0.1);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }

        /* Sparkle animation */
        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: white;
            box-shadow: 0 0 8px 2px rgba(255, 255, 255, 0.8);
            animation: twinkle 2s infinite;
        }

        @keyframes twinkle {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .form-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .form-input:focus {
            outline: none;
            border-color: #9370DB;
            box-shadow: 0 0 0 2px rgba(147, 112, 219, 0.2);
        }

        .submit-btn {
            background-color: #7a52c7;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            font-size: 16px;
        }

        /* Tally card styles */
        .tally-card {
            background-color: #f8f4ff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .tally-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .tally-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }

        .tally-title {
            font-weight: 600;
            color: #7a52c7;
            font-size: 1.1rem;
        }

        .tally-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .tally-item:last-child {
            border-bottom: none;
        }

        .tally-bar-container {
            flex-grow: 1;
            height: 12px;
            background-color: #e9e1f8;
            border-radius: 6px;
            margin: 0 15px;
            overflow: hidden;
        }

        .tally-bar {
            height: 100%;
            background-color: #9370DB;
            border-radius: 6px;
        }

        .tally-count {
            font-weight: 600;
            color: #7a52c7;
            min-width: 30px;
            text-align: right;
        }

        /* Flip card for RSVP list */
        .flip-card {
            perspective: 1000px;
            height: 300px;
            margin-bottom: 20px;
        }

        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 12px;
            overflow: hidden;
        }

        .flip-card-back {
            transform: rotateY(180deg);
            background-color: white;
            padding: 15px;
            overflow-y: auto;
        }

        .submit-btn:hover {
            background-color: #63439e;
        }

        .message-board {
            height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #fafafa;
        }

        .message-item {
            padding: 12px 16px;
            border-bottom: 1px solid #e0e0e0;
            transition: background-color 0.2s;
        }

        .message-item:hover {
            background-color: #f5f0ff;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .message-sender {
            font-weight: 600;
            color: #7a52c7;
        }

        .message-time {
            font-size: 0.8rem;
            color: #888;
        }

        .message-content {
            line-height: 1.4;
        }

        .send-btn {
            background-color: #7a52c7;
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .send-btn:hover {
            background-color: #63439e;
        }

        .suggestion-list {
            list-style-type: none;
            padding-left: 0;
            margin: 0;
        }

        .suggestion-list li {
            padding: 8px 0;
            display: flex;
            align-items: center;
        }

        .suggestion-list li::before {
            content: "â€¢";
            color: #9370DB;
            font-weight: bold;
            display: inline-block;
            width: 1em;
            margin-right: 8px;
            font-size: 20px;
        }

        .page-title {
            text-align: center;
            font-size: 3rem;
            font-weight: 700;
            color: #4b2e83;
            margin-bottom: 0.5rem;
            margin-top: 1rem;
            font-family: 'Playfair Display', serif;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            letter-spacing: 0.5px;
            position: relative;
        }

        .page-title::after {
            content: '';
            display: block;
            width: 100px;
            height: 3px;
            background: linear-gradient(to right, #9370DB, #7a52c7);
            margin: 10px auto 0;
            border-radius: 3px;
        }

        .family-crest {
            position: relative;
            transition: all 0.3s ease;
            animation: gentle-pulse 3s infinite alternate;
        }

        @keyframes gentle-pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        .family-crest::before,
        .family-crest::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40px;
            height: 2px;
            background: linear-gradient(to right, transparent, rgba(122, 82, 199, 0.5));
        }

        .family-crest::before {
            left: -60px;
            transform: translateY(-50%);
        }

        .family-crest::after {
            right: -60px;
            transform: translateY(-50%) rotate(180deg);
        }

        /* Video chat styles */
        #local-video, #remote-video {
            background-color: #2d3748;
            transition: all 0.3s ease;
        }

        #local-video {
            transform: scaleX(-1); /* Mirror the local video */
        }

        .video-container {
            position: relative;
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.3);
            color: white;
            z-index: 10;
        }

        .video-controls {
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            z-index: 20;
        }

        .video-control-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .video-control-btn:hover {
            background-color: rgba(0, 0, 0, 0.7);
            transform: scale(1.1);
        }

        .video-status {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 20;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .video-status i {
            font-size: 10px;
        }

        /* Dark mode video styles */
        .dark-mode #local-video,
        .dark-mode #remote-video {
            background-color: #1a202c;
            border-color: #4a5568;
        }
    </style>
    <!-- ðŸ”µ END REGION: UI STYLES -->
</head>
<body>
    <!-- ðŸŸ¢ REGION: CORE -->
    <div id="app" class="min-h-screen"></div>
    <!-- ðŸŸ¢ END REGION: CORE -->

    <!-- React, ReactDOM, and Babel (production versions) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <!-- Note: In a production environment, you should precompile your scripts instead of using babel-standalone -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.4/babel.min.js"></script>

    <!-- WebRTC adapter for cross-browser compatibility -->
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>

    <!-- Axios for HTTP requests -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

    <!-- QR Code generation and scanning -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <!-- Crypto utilities for secure communication -->
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl-util@0.15.1/nacl-util.min.js"></script>

    <!-- LEEWAY WebRTC client for secure P2P communication (embedded) -->
    <script>
    /**
     * SecurePeerManager - A client for secure WebRTC signaling with QR code peer discovery
     *
     * This class handles WebRTC connection establishment, ICE candidate exchange,
     * encrypted signaling, QR code-based peer discovery, and connection state monitoring.
     */
    class SecurePeerManager {
        /**
         * Generate a cryptographically secure random session ID
         * @returns {string} A secure random session ID
         */
        static generateSessionId() {
            const array = new Uint8Array(16);
            crypto.getRandomValues(array);
            return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
        }

        /**
         * Generate a key pair for encryption
         * @returns {Object} Object containing publicKey and secretKey
         */
        static generateKeyPair() {
            return nacl.box.keyPair();
        }

        /**
         * Encrypt a message using the recipient's public key
         * @param {Object} message - Message to encrypt
         * @param {Uint8Array} publicKey - Recipient's public key
         * @param {Uint8Array} secretKey - Sender's secret key
         * @returns {Object} Encrypted message with nonce
         */
        static encryptMessage(message, publicKey, secretKey) {
            const messageStr = JSON.stringify(message);
            const messageUint8 = nacl.util.decodeUTF8(messageStr);
            const nonce = nacl.randomBytes(nacl.box.nonceLength);
            const encrypted = nacl.box(messageUint8, nonce, publicKey, secretKey);

            return {
                encrypted: nacl.util.encodeBase64(encrypted),
                nonce: nacl.util.encodeBase64(nonce)
            };
        }

        /**
         * Decrypt a message using the sender's public key
         * @param {Object} encryptedMessage - Encrypted message with nonce
         * @param {Uint8Array} publicKey - Sender's public key
         * @param {Uint8Array} secretKey - Recipient's secret key
         * @returns {Object} Decrypted message
         */
        static decryptMessage(encryptedMessage, publicKey, secretKey) {
            const encrypted = nacl.util.decodeBase64(encryptedMessage.encrypted);
            const nonce = nacl.util.decodeBase64(encryptedMessage.nonce);
            const decrypted = nacl.box.open(encrypted, nonce, publicKey, secretKey);

            if (!decrypted) {
                throw new Error('Failed to decrypt message');
            }

            const messageStr = nacl.util.encodeUTF8(decrypted);
            return JSON.parse(messageStr);
        }

        /**
         * Generate a QR code from connection data
         * @param {Object} connectionData - Connection data to encode in QR
         * @param {HTMLElement} element - Element to render QR code in
         * @returns {Promise} Promise that resolves when QR code is generated
         */
        static generateQRCode(connectionData, element) {
            const data = JSON.stringify(connectionData);
            return QRCode.toCanvas(element, data, {
                width: 300,
                margin: 2,
                color: {
                    dark: '#7a52c7',  // Purple color for QR code
                    light: '#ffffff'   // White background
                }
            });
        }

        /**
         * Scan a QR code from video stream
         * @param {MediaStream} stream - Video stream to scan
         * @returns {Promise} Promise that resolves with scanned data
         */
        static scanQRCode(stream) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');

                video.srcObject = stream;
                video.play();

                const scanInterval = setInterval(() => {
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);

                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height);

                        if (code) {
                            clearInterval(scanInterval);
                            video.pause();
                            video.srcObject = null;
                            try {
                                const data = JSON.parse(code.data);
                                resolve(data);
                            } catch (e) {
                                reject(new Error('Invalid QR code data'));
                            }
                        }
                    }
                }, 100);

                // Timeout after 30 seconds
                setTimeout(() => {
                    clearInterval(scanInterval);
                    video.pause();
                    video.srcObject = null;
                    reject(new Error('QR code scan timeout'));
                }, 30000);
            });
        }
    }

    /**
     * WebSocketClient - A client for WebRTC signaling
     *
     * This class is maintained for backward compatibility but uses
     * the SecurePeerManager for enhanced security and functionality.
     */
    class WebSocketClient {
        constructor() {
            // WebRTC
            this.peerConnections = {}; // userId -> RTCPeerConnection
            this.localStream = null;
            this.iceServers = [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun.stunprotocol.org:3478' },
                // Add TURN servers for better NAT traversal in production
                {
                    urls: 'turn:global.turn.twilio.com:3478?transport=udp',
                    username: 'leeway_system',
                    credential: 'leeway_credential'
                }
            ];

            // Connection state
            this.connected = false;

            // LEEWAY system info
            this.systemName = 'LEEWAY WebRTC';
            this.systemVersion = '5.0';

            // Secure communication
            this.sessionId = SecurePeerManager.generateSessionId();
            this.keyPair = SecurePeerManager.generateKeyPair();
            this.peerPublicKeys = {}; // userId -> publicKey

            // Data channels for secure messaging
            this.dataChannels = {}; // userId -> RTCDataChannel

            // Callbacks
            this.onConnectionStatusChangeCallback = null;
            this.onUserJoinedCallback = null;
            this.onTrackCallback = null;
            this.onMessageCallback = null;
            this.onIceConnectionStateChangeCallback = null;
            this.onSpeakingCallback = null; // New callback for audio level detection

            console.log(`${this.systemName} v${this.systemVersion} initialized with secure signaling`);
            console.log(`Session ID: ${this.sessionId}`);
        }

        /**
         * Connect to the peer-to-peer network
         * @param {Object} options - Connection options
         * @param {boolean} options.showQR - Whether to show QR code for connection
         * @param {HTMLElement} options.qrElement - Element to render QR code in
         * @returns {Promise} Resolves when ready for connections
         */
        connect(options = {}) {
            return new Promise((resolve) => {
                console.log(`${this.systemName} system ready for connections`);

                // Log ICE servers being used
                console.log('Using ICE servers:', this.iceServers);

                // Create connection data for QR code
                const connectionData = {
                    sessionId: this.sessionId,
                    publicKey: nacl.util.encodeBase64(this.keyPair.publicKey),
                    iceServers: this.iceServers
                };

                // Generate QR code if requested
                if (options.showQR && options.qrElement) {
                    SecurePeerManager.generateQRCode(connectionData, options.qrElement)
                        .then(() => {
                            console.log('QR code generated for peer connection');
                        })
                        .catch(error => {
                            console.error('Error generating QR code:', error);
                        });
                }

                this.connected = true;

                if (this.onConnectionStatusChangeCallback) {
                    this.onConnectionStatusChangeCallback('connected');
                }

                // Resolve immediately since we're not waiting for any server connection
                resolve(connectionData);
            });
        }

        /**
         * Connect to a peer using QR code
         * @param {MediaStream} cameraStream - Camera stream for QR code scanning
         * @returns {Promise} Resolves with peer connection data
         */
        connectWithQRCode(cameraStream) {
            return new Promise((resolve, reject) => {
                // Scan QR code
                SecurePeerManager.scanQRCode(cameraStream)
                    .then(peerData => {
                        console.log('QR code scanned successfully:', peerData);

                        // Store peer's public key
                        try {
                            const peerPublicKey = nacl.util.decodeBase64(peerData.publicKey);
                            this.peerPublicKeys[peerData.sessionId] = peerPublicKey;

                            // Create direct connection to peer
                            const peerConnection = this.createDirectConnection(peerData.sessionId);

                            // Create secure data channel
                            this._createSecureDataChannel(peerData.sessionId, peerConnection);

                            resolve(peerData);
                        } catch (error) {
                            console.error('Error processing peer data:', error);
                            reject(error);
                        }
                    })
                    .catch(error => {
                        console.error('Error scanning QR code:', error);
                        reject(error);
                    });
            });
        }

        /**
         * Create a secure data channel for encrypted messaging
         * @param {string} userId - ID of the remote user
         * @param {RTCPeerConnection} peerConnection - The peer connection
         * @private
         */
        _createSecureDataChannel(userId, peerConnection) {
            try {
                // Create a data channel for secure messaging
                const dataChannel = peerConnection.createDataChannel('secure-messages', {
                    ordered: true,
                    maxRetransmits: 10
                });

                // Set up data channel event handlers
                dataChannel.onopen = () => {
                    console.log(`Secure data channel opened with ${userId}`);
                    this.dataChannels[userId] = dataChannel;
                };

                dataChannel.onclose = () => {
                    console.log(`Secure data channel closed with ${userId}`);
                    delete this.dataChannels[userId];
                };

                dataChannel.onmessage = (event) => {
                    try {
                        // Parse the encrypted message
                        const encryptedMessage = JSON.parse(event.data);

                        // Decrypt the message
                        const peerPublicKey = this.peerPublicKeys[userId];
                        if (!peerPublicKey) {
                            console.error(`No public key found for user ${userId}`);
                            return;
                        }

                        const decryptedMessage = SecurePeerManager.decryptMessage(
                            encryptedMessage,
                            peerPublicKey,
                            this.keyPair.secretKey
                        );

                        console.log(`Received secure message from ${userId}:`, decryptedMessage);

                        // Call the message callback if provided
                        if (this.onMessageCallback) {
                            this.onMessageCallback(userId, decryptedMessage);
                        }
                    } catch (error) {
                        console.error('Error processing encrypted message:', error);
                    }
                };

                // Handle data channel events on the peer connection
                peerConnection.ondatachannel = (event) => {
                    const receivedChannel = event.channel;

                    receivedChannel.onopen = () => {
                        console.log(`Data channel from ${userId} opened`);
                        this.dataChannels[userId] = receivedChannel;
                    };

                    receivedChannel.onclose = () => {
                        console.log(`Data channel from ${userId} closed`);
                        delete this.dataChannels[userId];
                    };

                    receivedChannel.onmessage = (event) => {
                        try {
                            // Parse the encrypted message
                            const encryptedMessage = JSON.parse(event.data);

                            // Decrypt the message
                            const peerPublicKey = this.peerPublicKeys[userId];
                            if (!peerPublicKey) {
                                console.error(`No public key found for user ${userId}`);
                                return;
                            }

                            const decryptedMessage = SecurePeerManager.decryptMessage(
                                encryptedMessage,
                                peerPublicKey,
                                this.keyPair.secretKey
                            );

                            console.log(`Received secure message from ${userId}:`, decryptedMessage);

                            // Call the message callback if provided
                            if (this.onMessageCallback) {
                                this.onMessageCallback(userId, decryptedMessage);
                            }
                        } catch (error) {
                            console.error('Error processing encrypted message:', error);
                        }
                    };
                };

                return dataChannel;
            } catch (error) {
                console.error('Error creating secure data channel:', error);
                return null;
            }
        }

        /**
         * Send an encrypted message to a peer
         * @param {string} userId - ID of the recipient
         * @param {Object} message - Message to send
         * @returns {boolean} Whether the message was sent successfully
         */
        sendSecureMessage(userId, message) {
            const dataChannel = this.dataChannels[userId];
            const peerPublicKey = this.peerPublicKeys[userId];

            if (!dataChannel || dataChannel.readyState !== 'open') {
                console.error(`No open data channel for user ${userId}`);
                return false;
            }

            if (!peerPublicKey) {
                console.error(`No public key found for user ${userId}`);
                return false;
            }

            try {
                // Add timestamp and sender ID to the message
                const messageWithMetadata = {
                    ...message,
                    timestamp: Date.now(),
                    senderId: this.sessionId
                };

                // Encrypt the message
                const encryptedMessage = SecurePeerManager.encryptMessage(
                    messageWithMetadata,
                    peerPublicKey,
                    this.keyPair.secretKey
                );

                // Send the encrypted message
                dataChannel.send(JSON.stringify(encryptedMessage));
                return true;
            } catch (error) {
                console.error('Error sending secure message:', error);
                return false;
            }
        }

        /**
         * Set callback for speaking detection
         * @param {Function} callback - Function to call when speaking is detected
         */
        onSpeaking(callback) {
            this.onSpeakingCallback = callback;
        }

        /**
         * Set up audio level detection for a stream
         * @param {MediaStream} stream - Media stream to monitor
         * @param {boolean} isLocal - Whether this is the local stream
         * @param {string} userId - ID of the user (for remote streams)
         * @private
         */
        _setupAudioLevelDetection(stream, isLocal, userId = null) {
            if (!stream) return;

            // Find audio track
            const audioTrack = stream.getAudioTracks()[0];
            if (!audioTrack) return;

            try {
                // Create audio context
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(stream);
                const analyser = audioContext.createAnalyser();

                // Configure analyser
                analyser.fftSize = 256;
                analyser.smoothingTimeConstant = 0.8;
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                // Connect source to analyser
                source.connect(analyser);

                // Don't connect to destination for local stream to avoid feedback
                // analyser.connect(audioContext.destination);

                // Variables for speaking detection
                let isSpeaking = false;
                let speakingThreshold = isLocal ? 30 : 20; // Lower threshold for remote streams
                let silenceCounter = 0;

                // Check audio level periodically
                const checkAudioLevel = () => {
                    // Get audio data
                    analyser.getByteFrequencyData(dataArray);

                    // Calculate average volume
                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        sum += dataArray[i];
                    }
                    const average = sum / bufferLength;

                    // Detect speaking
                    const wasSpeaking = isSpeaking;

                    if (average > speakingThreshold) {
                        isSpeaking = true;
                        silenceCounter = 0;
                    } else {
                        silenceCounter++;
                        // Only mark as not speaking after a short period of silence
                        if (silenceCounter > 5) {
                            isSpeaking = false;
                        }
                    }

                    // Notify if speaking state changed
                    if (wasSpeaking !== isSpeaking && this.onSpeakingCallback) {
                        if (isLocal) {
                            this.onSpeakingCallback('local', isSpeaking, average);
                        } else if (userId) {
                            this.onSpeakingCallback(userId, isSpeaking, average);
                        }
                    }

                    // Continue checking
                    requestAnimationFrame(checkAudioLevel);
                };

                // Start checking
                checkAudioLevel();

            } catch (error) {
                console.error('Error setting up audio level detection:', error);
            }
        }

        /**
         * Disconnect and clean up resources
         */
        disconnect() {
            // Close all peer connections
            Object.values(this.peerConnections).forEach(pc => {
                if (pc) {
                    pc.close();
                }
            });

            this.peerConnections = {};
            this.connected = false;

            if (this.onConnectionStatusChangeCallback) {
                this.onConnectionStatusChangeCallback('disconnected');
            }
        }

        /**
         * Add local media stream
         * @param {MediaStream} stream - Local media stream
         */
        addLocalStream(stream) {
            this.localStream = stream;
        }

        /**
         * Initiate a call to a user
         * @param {string} userId - ID of the user to call
         * @param {MediaStream} stream - Local media stream
         */
        initiateCall(userId, stream) {
            if (!this.connected) {
                console.error('Cannot initiate call: Not connected');
                return;
            }

            if (!stream) {
                console.error('Cannot initiate call: No local stream provided');
                return;
            }

            this.localStream = stream;

            // Create a peer connection and return it
            return this._createPeerConnection(userId, true);
        }

        /**
         * Set callback for connection status changes
         * @param {Function} callback - Function to call on status change
         */
        onConnectionStatusChange(callback) {
            this.onConnectionStatusChangeCallback = callback;
        }

        /**
         * Set callback for when a user joins
         * @param {Function} callback - Function to call when a user joins
         */
        onUserJoined(callback) {
            this.onUserJoinedCallback = callback;
        }

        /**
         * Set callback for when a track is received
         * @param {Function} callback - Function to call when a track is received
         */
        onTrack(callback) {
            this.onTrackCallback = callback;
        }

        /**
         * Set callback for when a message is received
         * @param {Function} callback - Function to call when a message is received
         */
        onMessage(callback) {
            this.onMessageCallback = callback;
        }

        /**
         * Set callback for ICE connection state changes
         * @param {Function} callback - Function to call on ICE state change
         */
        onIceConnectionStateChange(callback) {
            this.onIceConnectionStateChangeCallback = callback;
        }

        /**
         * Send a message to a peer
         * @param {Object} message - Message to send
         * @private
         */
        _sendMessage(message) {
            console.log('LEEWAY direct message:', message);

            // In a real implementation, this would send the message through a signaling channel
            // For now, we'll simulate direct peer communication

            // If this is an offer or answer, handle it directly
            if (message.type === 'offer' || message.type === 'answer') {
                const targetPeerConnection = this.peerConnections[message.userId];
                if (targetPeerConnection) {
                    if (message.type === 'offer') {
                        this._handleOffer(message);
                    } else if (message.type === 'answer') {
                        this._handleAnswer(message);
                    }
                }
            }

            // If this is an ICE candidate, handle it directly
            if (message.type === 'ice-candidate') {
                this._handleIceCandidate(message);
            }
        }

        /**
         * Create a new RTCPeerConnection
         * @param {string} userId - ID of the remote user
         * @param {boolean} isInitiator - Whether this client is initiating the connection
         * @private
         */
        _createPeerConnection(userId, isInitiator) {
            try {
                // Close existing connection if any
                if (this.peerConnections[userId]) {
                    this.peerConnections[userId].close();
                }

                // Create new connection with enhanced ICE server configuration
                const peerConnection = new RTCPeerConnection({
                    iceServers: this.iceServers,
                    iceTransportPolicy: 'all', // Use 'relay' to force TURN usage
                    iceCandidatePoolSize: 10,
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require',
                    sdpSemantics: 'unified-plan'
                });

                // Add local tracks to the connection
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, this.localStream);
                    });

                    // Set up audio level detection for local stream
                    this._setupAudioLevelDetection(this.localStream, true);
                }

                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        this._sendMessage({
                            type: 'ice-candidate',
                            candidate: event.candidate,
                            userId: userId
                        });
                    }
                };

                // Monitor ICE connection state
                peerConnection.oniceconnectionstatechange = () => {
                    console.log(`ICE connection state for ${userId}: ${peerConnection.iceConnectionState}`);

                    // Handle different ICE connection states
                    switch (peerConnection.iceConnectionState) {
                        case 'failed':
                            console.error(`ICE connection failed for peer ${userId}`);
                            // Attempt to restart ICE
                            this._restartIce(userId, peerConnection);
                            break;

                        case 'disconnected':
                            console.warn(`ICE connection disconnected for peer ${userId}`);
                            // Wait briefly to see if it reconnects automatically
                            setTimeout(() => {
                                if (peerConnection.iceConnectionState === 'disconnected') {
                                    this._restartIce(userId, peerConnection);
                                }
                            }, 5000);
                            break;

                        case 'connected':
                        case 'completed':
                            console.log(`ICE connection established for peer ${userId}`);
                            break;
                    }

                    // Call the callback if provided
                    if (this.onIceConnectionStateChangeCallback) {
                        this.onIceConnectionStateChangeCallback(userId, peerConnection.iceConnectionState);
                    }
                };

                // Monitor connection state
                peerConnection.onconnectionstatechange = () => {
                    console.log(`Connection state for ${userId}: ${peerConnection.connectionState}`);

                    // Handle different connection states
                    switch (peerConnection.connectionState) {
                        case 'failed':
                            console.error(`Connection failed for peer ${userId}`);
                            // Notify the application
                            if (this.onConnectionStatusChangeCallback) {
                                this.onConnectionStatusChangeCallback('peer-failed');
                            }
                            break;
                        case 'connected':
                            console.log(`Connection established for peer ${userId}`);
                            break;
                    }
                };

                // Handle remote tracks
                peerConnection.ontrack = (event) => {
                    console.log(`Received remote track from ${userId}`, event.streams[0]);

                    // Set up audio level detection for remote stream
                    this._setupAudioLevelDetection(event.streams[0], false, userId);

                    if (this.onTrackCallback) {
                        this.onTrackCallback(userId, event.streams[0]);
                    }
                };

                // Store the connection
                this.peerConnections[userId] = peerConnection;

                // If initiator, create and send offer
                if (isInitiator) {
                    this._createAndSendOffer(userId, peerConnection);
                }

                return peerConnection;
            } catch (error) {
                console.error('Error creating peer connection:', error);
                return null;
            }
        }

        /**
         * Restart ICE connection for a peer
         * @param {string} userId - ID of the remote user
         * @param {RTCPeerConnection} peerConnection - The peer connection to restart
         * @private
         */
        _restartIce(userId, peerConnection) {
            console.log(`Attempting to restart ICE for peer ${userId}`);

            try {
                // For modern browsers that support restartIce()
                if (peerConnection.restartIce) {
                    peerConnection.restartIce();
                    console.log(`ICE restart initiated for peer ${userId}`);
                    return;
                }

                // Fallback for browsers that don't support restartIce()
                // Create a new offer with ICE restart flag
                const offerOptions = {
                    iceRestart: true
                };

                peerConnection.createOffer(offerOptions)
                    .then(offer => {
                        return peerConnection.setLocalDescription(offer);
                    })
                    .then(() => {
                        // Send the new offer to the peer
                        this._sendMessage({
                            type: 'offer',
                            sdp: peerConnection.localDescription,
                            userId: userId,
                            iceRestart: true
                        });
                        console.log(`ICE restart offer sent for peer ${userId}`);
                    })
                    .catch(error => {
                        console.error(`Error restarting ICE for peer ${userId}:`, error);
                    });
            } catch (error) {
                console.error(`Error during ICE restart for peer ${userId}:`, error);
            }
        }

        /**
         * Create and send an offer to a peer
         * @param {string} userId - ID of the remote user
         * @param {RTCPeerConnection} peerConnection - The peer connection
         * @private
         */
        _createAndSendOffer(userId, peerConnection) {
            peerConnection.createOffer()
                .then(offer => {
                    return peerConnection.setLocalDescription(offer);
                })
                .then(() => {
                    this._sendMessage({
                        type: 'offer',
                        sdp: peerConnection.localDescription,
                        userId: userId
                    });
                })
                .catch(error => {
                    console.error('Error creating offer:', error);
                });
        }

        /**
         * Handle an offer from a peer
         * @param {Object} message - The offer message
         * @private
         */
        _handleOffer(message) {
            const userId = message.userId;

            // Create peer connection if it doesn't exist
            const peerConnection = this.peerConnections[userId] || this._createPeerConnection(userId, false);

            // Set remote description
            peerConnection.setRemoteDescription(new RTCSessionDescription(message.sdp))
                .then(() => {
                    // Create answer
                    return peerConnection.createAnswer();
                })
                .then(answer => {
                    // Set local description
                    return peerConnection.setLocalDescription(answer);
                })
                .then(() => {
                    // Send answer
                    this._sendMessage({
                        type: 'answer',
                        sdp: peerConnection.localDescription,
                        userId: userId
                    });
                })
                .catch(error => {
                    console.error('Error handling offer:', error);
                });
        }

        /**
         * Handle an answer from a peer
         * @param {Object} message - The answer message
         * @private
         */
        _handleAnswer(message) {
            const userId = message.userId;
            const peerConnection = this.peerConnections[userId];

            if (peerConnection) {
                peerConnection.setRemoteDescription(new RTCSessionDescription(message.sdp))
                    .catch(error => {
                        console.error('Error setting remote description from answer:', error);
                    });
            }
        }

        /**
         * Handle an ICE candidate from a peer
         * @param {Object} message - The ICE candidate message
         * @private
         */
        _handleIceCandidate(message) {
            const userId = message.userId;
            const peerConnection = this.peerConnections[userId];

            if (peerConnection) {
                peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate))
                    .catch(error => {
                        console.error('Error adding ICE candidate:', error);
                    });
            }
        }

        /**
         * Handle a user leaving
         * @param {Object} message - The user-left message
         * @private
         */
        _handleUserLeft(message) {
            const userId = message.userId;
            const peerConnection = this.peerConnections[userId];

            if (peerConnection) {
                peerConnection.close();
                delete this.peerConnections[userId];
            }
        }

        /**
         * Initiate a direct peer connection
         * @param {string} userId - ID to assign to the peer
         */
        createDirectConnection(userId) {
            console.log(`Creating direct connection to peer: ${userId}`);

            // Create a peer connection
            const peerConnection = this._createPeerConnection(userId, true);

            // Notify the application
            if (this.onUserJoinedCallback) {
                this.onUserJoinedCallback(userId, 'direct');
            }

            return peerConnection;
        }
    }

    // Make the class available globally
    window.WebSocketClient = WebSocketClient;
    </script>

    <!-- ðŸ§  REGION: AI & MAIN APP CODE -->
    <script type="text/babel">
        // Local Storage Database System
        const LocalDB = {
            // Initialize collections
            init: () => {
                if (!localStorage.getItem('attendees')) localStorage.setItem('attendees', JSON.stringify([]));
                if (!localStorage.getItem('messages')) localStorage.setItem('messages', JSON.stringify([]));
                if (!localStorage.getItem('activities')) localStorage.setItem('activities', JSON.stringify([]));
                if (!localStorage.getItem('foods')) localStorage.setItem('foods', JSON.stringify([]));
                if (!localStorage.getItem('users')) localStorage.setItem('users', JSON.stringify([]));
                if (!localStorage.getItem('calls')) localStorage.setItem('calls', JSON.stringify([]));
            },

            // Get all items from a collection
            getAll: (collection) => {
                const data = localStorage.getItem(collection);
                return data ? JSON.parse(data) : [];
            },

            // Add an item to a collection
            add: (collection, item) => {
                const data = LocalDB.getAll(collection);
                const id = 'id_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const newItem = { ...item, id };
                data.push(newItem);
                localStorage.setItem(collection, JSON.stringify(data));
                return newItem;
            },

            // Update an item in a collection
            update: (collection, id, updates) => {
                const data = LocalDB.getAll(collection);
                const index = data.findIndex(item => item.id === id);
                if (index !== -1) {
                    data[index] = { ...data[index], ...updates };
                    localStorage.setItem(collection, JSON.stringify(data));
                    return data[index];
                }
                return null;
            },

            // Delete an item from a collection
            delete: (collection, id) => {
                const data = LocalDB.getAll(collection);
                const filtered = data.filter(item => item.id !== id);
                localStorage.setItem(collection, JSON.stringify(filtered));
                return true;
            },

            // Clear a collection
            clear: (collection) => {
                localStorage.setItem(collection, JSON.stringify([]));
                return true;
            },

            // Query items in a collection
            query: (collection, field, operator, value) => {
                const data = LocalDB.getAll(collection);
                let results = [];

                switch (operator) {
                    case '==':
                        results = data.filter(item => item[field] === value);
                        break;
                    case '!=':
                        results = data.filter(item => item[field] !== value);
                        break;
                    case '>':
                        results = data.filter(item => item[field] > value);
                        break;
                    case '>=':
                        results = data.filter(item => item[field] >= value);
                        break;
                    case '<':
                        results = data.filter(item => item[field] < value);
                        break;
                    case '<=':
                        results = data.filter(item => item[field] <= value);
                        break;
                    case 'contains':
                        results = data.filter(item =>
                            Array.isArray(item[field]) && item[field].includes(value)
                        );
                        break;
                    default:
                        results = data;
                }

                return results;
            }
        };

        // Initialize local database
        LocalDB.init();

        // Collection references (simulating Firebase collections)
        const attendeesCollection = {
            add: (data) => LocalDB.add('attendees', data),
            get: () => ({
                docs: LocalDB.getAll('attendees').map(doc => ({
                    id: doc.id,
                    data: () => doc
                })),
                empty: LocalDB.getAll('attendees').length === 0
            }),
            doc: (id) => ({
                get: () => {
                    const doc = LocalDB.getAll('attendees').find(item => item.id === id);
                    return {
                        exists: !!doc,
                        data: () => doc,
                        id
                    };
                },
                delete: () => LocalDB.delete('attendees', id),
                update: (data) => LocalDB.update('attendees', id, data)
            }),
            where: (field, operator, value) => {
                // Store the current query criteria
                const criteria = [{ field, operator, value }];

                // Create a query object that can be chained
                const queryObj = {
                    where: (field, operator, value) => {
                        // Add additional criteria
                        criteria.push({ field, operator, value });
                        return queryObj;
                    },
                    get: () => {
                        // Start with all attendees
                        let results = LocalDB.getAll('attendees');

                        // Apply each criteria in sequence
                        criteria.forEach(({ field, operator, value }) => {
                            results = results.filter(doc => {
                                switch (operator) {
                                    case '==':
                                        return doc[field] === value;
                                    case '!=':
                                        return doc[field] !== value;
                                    case '>':
                                        return doc[field] > value;
                                    case '>=':
                                        return doc[field] >= value;
                                    case '<':
                                        return doc[field] < value;
                                    case '<=':
                                        return doc[field] <= value;
                                    case 'contains':
                                        return Array.isArray(doc[field]) && doc[field].includes(value);
                                    default:
                                        return true;
                                }
                            });
                        });

                        return {
                            empty: results.length === 0,
                            docs: results.map(doc => ({
                                id: doc.id,
                                data: () => doc
                            }))
                        };
                    }
                };

                return queryObj;
            },
            onSnapshot: (callback) => {
                // Simulate real-time updates by returning current data
                const handleStorageChange = () => {
                    const snapshot = {
                        docs: LocalDB.getAll('attendees').map(doc => ({
                            id: doc.id,
                            data: () => doc
                        }))
                    };
                    callback(snapshot);
                };

                // Call immediately with current data
                handleStorageChange();

                // Listen for storage events (won't work in same tab, but simulates the concept)
                window.addEventListener('storage', handleStorageChange);

                // Return unsubscribe function
                return () => window.removeEventListener('storage', handleStorageChange);
            }
        };

        const messagesCollection = {
            add: (data) => LocalDB.add('messages', data),
            get: () => ({
                docs: LocalDB.getAll('messages').map(doc => ({
                    id: doc.id,
                    data: () => doc
                })),
                empty: LocalDB.getAll('messages').length === 0
            }),
            doc: (id) => ({
                get: () => {
                    const doc = LocalDB.getAll('messages').find(item => item.id === id);
                    return {
                        exists: !!doc,
                        data: () => doc,
                        id
                    };
                },
                delete: () => LocalDB.delete('messages', id),
                update: (data) => LocalDB.update('messages', id, data)
            }),
            where: (field, operator, value) => {
                // Store the current query criteria
                const criteria = [{ field, operator, value }];

                // Create a query object that can be chained
                const queryObj = {
                    where: (field, operator, value) => {
                        // Add additional criteria
                        criteria.push({ field, operator, value });
                        return queryObj;
                    },
                    get: () => {
                        // Start with all messages
                        let results = LocalDB.getAll('messages');

                        // Apply each criteria in sequence
                        criteria.forEach(({ field, operator, value }) => {
                            results = results.filter(doc => {
                                switch (operator) {
                                    case '==':
                                        return doc[field] === value;
                                    case '!=':
                                        return doc[field] !== value;
                                    case '>':
                                        return doc[field] > value;
                                    case '>=':
                                        return doc[field] >= value;
                                    case '<':
                                        return doc[field] < value;
                                    case '<=':
                                        return doc[field] <= value;
                                    case 'contains':
                                        return Array.isArray(doc[field]) && doc[field].includes(value);
                                    default:
                                        return true;
                                }
                            });
                        });

                        return {
                            empty: results.length === 0,
                            docs: results.map(doc => ({
                                id: doc.id,
                                data: () => doc
                            }))
                        };
                    }
                };

                return queryObj;
            },
            orderBy: () => ({
                onSnapshot: (callback) => {
                    // Simulate real-time updates by returning current data
                    const handleStorageChange = () => {
                        const snapshot = {
                            docs: LocalDB.getAll('messages').map(doc => ({
                                id: doc.id,
                                data: () => doc
                            }))
                        };
                        callback(snapshot);
                    };

                    // Call immediately with current data
                    handleStorageChange();

                    // Listen for storage events (won't work in same tab, but simulates the concept)
                    window.addEventListener('storage', handleStorageChange);

                    // Return unsubscribe function
                    return () => window.removeEventListener('storage', handleStorageChange);
                }
            }),
            onSnapshot: (callback) => {
                // Simulate real-time updates by returning current data
                const handleStorageChange = () => {
                    const snapshot = {
                        docs: LocalDB.getAll('messages').map(doc => ({
                            id: doc.id,
                            data: () => doc
                        }))
                    };
                    callback(snapshot);
                };

                // Call immediately with current data
                handleStorageChange();

                // Listen for storage events (won't work in same tab, but simulates the concept)
                window.addEventListener('storage', handleStorageChange);

                // Return unsubscribe function
                return () => window.removeEventListener('storage', handleStorageChange);
            }
        };

        const activitiesCollection = {
            add: (data) => LocalDB.add('activities', data),
            get: () => ({
                docs: LocalDB.getAll('activities').map(doc => ({
                    id: doc.id,
                    data: () => doc
                })),
                empty: LocalDB.getAll('activities').length === 0
            }),
            doc: (id) => ({
                get: () => {
                    const doc = LocalDB.getAll('activities').find(item => item.id === id);
                    return {
                        exists: !!doc,
                        data: () => doc,
                        id
                    };
                },
                delete: () => LocalDB.delete('activities', id),
                update: (data) => LocalDB.update('activities', id, data)
            }),
            where: (field, operator, value) => {
                // Store the current query criteria
                const criteria = [{ field, operator, value }];

                // Create a query object that can be chained
                const queryObj = {
                    where: (field, operator, value) => {
                        // Add additional criteria
                        criteria.push({ field, operator, value });
                        return queryObj;
                    },
                    get: () => {
                        // Start with all activities
                        let results = LocalDB.getAll('activities');

                        // Apply each criteria in sequence
                        criteria.forEach(({ field, operator, value }) => {
                            results = results.filter(doc => {
                                switch (operator) {
                                    case '==':
                                        return doc[field] === value;
                                    case '!=':
                                        return doc[field] !== value;
                                    case '>':
                                        return doc[field] > value;
                                    case '>=':
                                        return doc[field] >= value;
                                    case '<':
                                        return doc[field] < value;
                                    case '<=':
                                        return doc[field] <= value;
                                    case 'contains':
                                        return Array.isArray(doc[field]) && doc[field].includes(value);
                                    default:
                                        return true;
                                }
                            });
                        });

                        return {
                            empty: results.length === 0,
                            docs: results.map(doc => ({
                                id: doc.id,
                                data: () => doc
                            }))
                        };
                    }
                };

                return queryObj;
            },
            onSnapshot: (callback) => {
                // Simulate real-time updates by returning current data
                const handleStorageChange = () => {
                    const snapshot = {
                        docs: LocalDB.getAll('activities').map(doc => ({
                            id: doc.id,
                            data: () => doc
                        }))
                    };
                    callback(snapshot);
                };

                // Call immediately with current data
                handleStorageChange();

                // Listen for storage events (won't work in same tab, but simulates the concept)
                window.addEventListener('storage', handleStorageChange);

                // Return unsubscribe function
                return () => window.removeEventListener('storage', handleStorageChange);
            }
        };

        const foodsCollection = {
            add: (data) => LocalDB.add('foods', data),
            get: () => ({
                docs: LocalDB.getAll('foods').map(doc => ({
                    id: doc.id,
                    data: () => doc
                })),
                empty: LocalDB.getAll('foods').length === 0
            }),
            doc: (id) => ({
                get: () => {
                    const doc = LocalDB.getAll('foods').find(item => item.id === id);
                    return {
                        exists: !!doc,
                        data: () => doc,
                        id
                    };
                },
                delete: () => LocalDB.delete('foods', id),
                update: (data) => LocalDB.update('foods', id, data)
            }),
            where: (field, operator, value) => {
                // Store the current query criteria
                const criteria = [{ field, operator, value }];

                // Create a query object that can be chained
                const queryObj = {
                    where: (field, operator, value) => {
                        // Add additional criteria
                        criteria.push({ field, operator, value });
                        return queryObj;
                    },
                    get: () => {
                        // Start with all foods
                        let results = LocalDB.getAll('foods');

                        // Apply each criteria in sequence
                        criteria.forEach(({ field, operator, value }) => {
                            results = results.filter(doc => {
                                switch (operator) {
                                    case '==':
                                        return doc[field] === value;
                                    case '!=':
                                        return doc[field] !== value;
                                    case '>':
                                        return doc[field] > value;
                                    case '>=':
                                        return doc[field] >= value;
                                    case '<':
                                        return doc[field] < value;
                                    case '<=':
                                        return doc[field] <= value;
                                    case 'contains':
                                        return Array.isArray(doc[field]) && doc[field].includes(value);
                                    default:
                                        return true;
                                }
                            });
                        });

                        return {
                            empty: results.length === 0,
                            docs: results.map(doc => ({
                                id: doc.id,
                                data: () => doc
                            }))
                        };
                    }
                };

                return queryObj;
            },
            onSnapshot: (callback) => {
                // Simulate real-time updates by returning current data
                const handleStorageChange = () => {
                    const snapshot = {
                        docs: LocalDB.getAll('foods').map(doc => ({
                            id: doc.id,
                            data: () => doc
                        }))
                    };
                    callback(snapshot);
                };

                // Call immediately with current data
                handleStorageChange();

                // Listen for storage events (won't work in same tab, but simulates the concept)
                window.addEventListener('storage', handleStorageChange);

                // Return unsubscribe function
                return () => window.removeEventListener('storage', handleStorageChange);
            }
        };

        // Helper function to create a timestamp (replacing Firebase's serverTimestamp)
        const serverTimestamp = () => new Date().toISOString();

        // Mock Firebase objects
        const firebase = {
            firestore: {
                FieldValue: {
                    serverTimestamp: serverTimestamp
                },
                batch: () => {
                    const items = [];
                    return {
                        delete: (ref) => {
                            items.push({ type: 'delete', ref });
                        },
                        update: (ref, data) => {
                            items.push({ type: 'update', ref, data });
                        },
                        set: (ref, data) => {
                            items.push({ type: 'set', ref, data });
                        },
                        commit: async () => {
                            for (const item of items) {
                                if (item.type === 'delete') {
                                    if (item.ref.delete) {
                                        await item.ref.delete();
                                    }
                                } else if (item.type === 'update') {
                                    if (item.ref.update) {
                                        await item.ref.update(item.data);
                                    }
                                } else if (item.type === 'set') {
                                    if (item.ref.set) {
                                        await item.ref.set(item.data);
                                    }
                                }
                            }
                            return true;
                        }
                    };
                },
                runTransaction: async (callback) => {
                    // Simple mock for transactions
                    return await callback({
                        get: async (ref) => {
                            const result = await ref.get();
                            return result;
                        },
                        update: async (ref, data) => {
                            await ref.update(data);
                            return true;
                        }
                    });
                }
            },
            auth: () => ({
                currentUser: getCurrentUser(),
                signInAnonymously: () => Promise.resolve({ user: getCurrentUser() }),
                signOut: () => {
                    localStorage.removeItem('fakeUser');
                    return Promise.resolve();
                }
            }),
            database: () => ({
                ref: (path) => ({
                    set: (data) => {
                        const parts = path.split('/');
                        const collection = parts[0];
                        const existingData = LocalDB.getAll(collection) || [];
                        existingData.push(data);
                        localStorage.setItem(collection, JSON.stringify(existingData));
                        return Promise.resolve();
                    },
                    update: (data) => {
                        const parts = path.split('/');
                        const collection = parts[0];
                        const id = parts[1];
                        const existingData = LocalDB.getAll(collection) || [];
                        const index = existingData.findIndex(item => item.id === id);
                        if (index !== -1) {
                            existingData[index] = { ...existingData[index], ...data };
                            localStorage.setItem(collection, JSON.stringify(existingData));
                        }
                        return Promise.resolve();
                    },
                    push: (data) => {
                        const parts = path.split('/');
                        const collection = parts[0];
                        const newItem = LocalDB.add(collection, data);
                        return Promise.resolve({ key: newItem.id });
                    },
                    on: (event, callback) => {
                        // Simulate real-time updates
                        callback();
                        return () => {}; // Unsubscribe function
                    },
                    off: () => {}
                })
            })
        };

        // WebRTC configuration
        const peerConnectionConfig = {
            'iceServers': [
                { 'urls': 'stun:stun.stunprotocol.org:3478' },
                { 'urls': 'stun:stun.l.google.com:19302' },
            ]
        };

        // Global notification function
        const globalNotify = (message, type = 'info') => {
            // Create a notification element
            const notificationElement = document.createElement('div');
            notificationElement.className = `notification notification-${type}`;
            notificationElement.innerHTML = `
                <div class="notification-content">
                    <i class="notification-icon fas ${type === 'success' ? 'fa-check-circle' :
                                                    type === 'error' ? 'fa-exclamation-circle' :
                                                    type === 'warning' ? 'fa-exclamation-triangle' : 'fa-info-circle'}"></i>
                    <span>${message}</span>
                </div>
                <button class="notification-close">&times;</button>
            `;

            // Add styles if they don't exist
            if (!document.getElementById('global-notification-styles')) {
                const style = document.createElement('style');
                style.id = 'global-notification-styles';
                style.textContent = `
                    .notification-container {
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        z-index: 9999;
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                        max-width: 350px;
                    }
                    .notification {
                        background-color: white;
                        border-radius: 8px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                        padding: 12px 16px;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        animation: notification-slide-in 0.3s ease-out;
                        margin-bottom: 10px;
                    }
                    .notification-content {
                        display: flex;
                        align-items: center;
                        gap: 10px;
                    }
                    .notification-success {
                        border-left: 4px solid #10b981;
                    }
                    .notification-error {
                        border-left: 4px solid #ef4444;
                    }
                    .notification-warning {
                        border-left: 4px solid #f59e0b;
                    }
                    .notification-info {
                        border-left: 4px solid #3b82f6;
                    }
                    .notification-icon {
                        font-size: 18px;
                    }
                    .notification-success .notification-icon {
                        color: #10b981;
                    }
                    .notification-error .notification-icon {
                        color: #ef4444;
                    }
                    .notification-warning .notification-icon {
                        color: #f59e0b;
                    }
                    .notification-info .notification-icon {
                        color: #3b82f6;
                    }
                    .notification-close {
                        background: none;
                        border: none;
                        color: #6b7280;
                        cursor: pointer;
                        font-size: 18px;
                        padding: 0;
                        margin-left: 10px;
                    }
                    @keyframes notification-slide-in {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes notification-slide-out {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }

            // Create container if it doesn't exist
            let container = document.querySelector('.notification-container');
            if (!container) {
                container = document.createElement('div');
                container.className = 'notification-container';
                document.body.appendChild(container);
            }

            // Add notification to container
            container.appendChild(notificationElement);

            // Add close button functionality
            const closeButton = notificationElement.querySelector('.notification-close');
            closeButton.addEventListener('click', () => {
                notificationElement.style.animation = 'notification-slide-out 0.3s ease-in forwards';
                setTimeout(() => {
                    if (container.contains(notificationElement)) {
                        container.removeChild(notificationElement);
                    }
                    // Remove container if empty
                    if (container.children.length === 0) {
                        document.body.removeChild(container);
                    }
                }, 300);
            });

            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (container.contains(notificationElement)) {
                    notificationElement.style.animation = 'notification-slide-out 0.3s ease-in forwards';
                    setTimeout(() => {
                        if (container.contains(notificationElement)) {
                            container.removeChild(notificationElement);
                        }
                        // Remove container if empty
                        if (container.children.length === 0 && document.body.contains(container)) {
                            document.body.removeChild(container);
                        }
                    }, 300);
                }
            }, 5000);
        };

        // Add function to send SMS notification
        const sendSMSNotification = async (message) => {
            try {
                // IMPORTANT: In a production environment, you should NEVER include API keys in client-side code
                // Instead, you would:
                // 1. Create a backend API endpoint (e.g., using Node.js, Python, etc.)
                // 2. Store your Twilio credentials securely in environment variables on the server
                // 3. Call your backend API from here, which would then use the credentials to call Twilio

                // For GitHub and demo purposes, we'll simulate the SMS sending
                console.log('SIMULATED SMS:', message);

                // Create a visual notification to show what would happen
                const adminPhone = '+1 (414) 367-6211'; // Format for display only
                const twilioPhone = '+1 (844) 951-3845'; // Format for display only

                // Show notification in the app using the global notification function
                globalNotify(`Text message sent to admin: ${message}`, 'success');

                // Create a more detailed SMS simulation popup
                const smsElement = document.createElement('div');
                smsElement.className = 'sms-simulation';
                smsElement.innerHTML = `
                    <div class="sms-header">
                        <i class="fas fa-sms mr-2"></i> SMS Notification
                        <button class="sms-close">&times;</button>
                    </div>
                    <div class="sms-body">
                        <div class="sms-info">
                            <div><strong>From:</strong> ${twilioPhone}</div>
                            <div><strong>To:</strong> ${adminPhone}</div>
                            <div><strong>Time:</strong> ${new Date().toLocaleTimeString()}</div>
                        </div>
                        <div class="sms-message">
                            <div class="sms-bubble">
                                ${message}
                            </div>
                        </div>
                        <div class="sms-note">
                            <i class="fas fa-info-circle mr-1"></i> This is a simulation. In production, this would be sent via Twilio API.
                        </div>
                    </div>
                `;

                document.body.appendChild(smsElement);

                // Add styles for the SMS simulation
                if (!document.getElementById('sms-simulation-styles')) {
                    const style = document.createElement('style');
                    style.id = 'sms-simulation-styles';
                    style.textContent = `
                        .sms-simulation {
                            position: fixed;
                            bottom: 20px;
                            left: 20px;
                            width: 320px;
                            background-color: #f8f9fa;
                            border-radius: 12px;
                            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
                            z-index: 1000;
                            overflow: hidden;
                            animation: sms-slide-in 0.3s ease-out;
                            font-family: 'Poppins', sans-serif;
                        }

                        @keyframes sms-slide-in {
                            from { transform: translateY(100%); opacity: 0; }
                            to { transform: translateY(0); opacity: 1; }
                        }

                        @keyframes sms-slide-out {
                            from { transform: translateY(0); opacity: 1; }
                            to { transform: translateY(100%); opacity: 0; }
                        }

                        .sms-header {
                            background-color: #6b46c1;
                            color: white;
                            padding: 12px 15px;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            font-weight: 600;
                        }

                        .sms-close {
                            background: none;
                            border: none;
                            color: white;
                            font-size: 20px;
                            cursor: pointer;
                            padding: 0;
                            line-height: 1;
                        }

                        .sms-body {
                            padding: 15px;
                        }

                        .sms-info {
                            margin-bottom: 15px;
                            font-size: 13px;
                            color: #555;
                        }

                        .sms-message {
                            margin-bottom: 15px;
                        }

                        .sms-bubble {
                            background-color: #e2f5fe;
                            border-radius: 18px;
                            padding: 10px 15px;
                            display: inline-block;
                            max-width: 90%;
                            position: relative;
                            border-bottom-left-radius: 4px;
                        }

                        .sms-note {
                            font-size: 12px;
                            color: #888;
                            font-style: italic;
                            border-top: 1px solid #eee;
                            padding-top: 10px;
                        }
                    `;
                    document.head.appendChild(style);
                }

                // Add close button functionality
                const closeButton = smsElement.querySelector('.sms-close');
                closeButton.addEventListener('click', () => {
                    smsElement.style.animation = 'sms-slide-out 0.3s ease-in forwards';
                    setTimeout(() => {
                        smsElement.remove();
                    }, 300);
                });

                // Auto-remove after 8 seconds
                setTimeout(() => {
                    if (document.body.contains(smsElement)) {
                        smsElement.style.animation = 'sms-slide-out 0.3s ease-in forwards';
                        setTimeout(() => {
                            smsElement.remove();
                        }, 300);
                    }
                }, 8000);

                return true;
            } catch (error) {
                console.error('Error sending SMS notification:', error);
                globalNotify('Error sending text message to admin', 'error');
                return false;
            }
        };

        // Speech synthesis setup
        const speak = (text, voice = 'Emma') => {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                const voices = window.speechSynthesis.getVoices();
                const selectedVoice = voices.find(v => v.name.includes(voice)) || voices[0];
                utterance.voice = selectedVoice;
                utterance.rate = 1;
                utterance.pitch = 1;
                window.speechSynthesis.speak(utterance);

                return {
                    stop: () => window.speechSynthesis.cancel(),
                    finished: new Promise(resolve => {
                        utterance.onend = resolve;
                    })
                };
            }
            return {
                stop: () => {},
                finished: Promise.resolve()
            };
        };

        // Speech recognition setup with improved mobile support
        const setupSpeechRecognition = (onResult) => {
            // Check for both standard and webkit prefixed versions
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

            if (SpeechRecognition) {
                try {
                    const recognition = new SpeechRecognition();

                    // Configure for better mobile experience
                    recognition.continuous = false;
                    recognition.interimResults = true; // Enable interim results for better responsiveness
                    recognition.lang = 'en-US';
                    recognition.maxAlternatives = 3; // Get multiple alternatives for better accuracy

                    // Handle results
                    recognition.onresult = (event) => {
                        // Get the most recent result
                        const lastResultIndex = event.results.length - 1;
                        const transcript = event.results[lastResultIndex][0].transcript;

                        // Only process final results to avoid flickering on mobile
                        if (event.results[lastResultIndex].isFinal) {
                            console.log('Final speech result:', transcript);
                            onResult(transcript);
                        }
                    };

                    // Handle errors
                    recognition.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);

                        // Show user-friendly error messages
                        let errorMessage = 'Error with voice recognition';

                        switch(event.error) {
                            case 'network':
                                errorMessage = 'Network error. Please check your connection.';
                                break;
                            case 'not-allowed':
                            case 'service-not-allowed':
                                errorMessage = 'Microphone access denied. Please check permissions.';
                                break;
                            case 'aborted':
                                errorMessage = 'Voice input was aborted.';
                                break;
                            case 'audio-capture':
                                errorMessage = 'No microphone detected.';
                                break;
                            case 'no-speech':
                                errorMessage = 'No speech detected. Please try again.';
                                break;
                            default:
                                errorMessage = `Error: ${event.error}`;
                        }

                        // Use global notification function if available
                        if (typeof globalNotify === 'function') {
                            globalNotify(errorMessage, 'error');
                        } else {
                            alert(errorMessage);
                        }
                    };

                    // Return enhanced interface
                    return {
                        start: () => {
                            try {
                                recognition.start();
                                console.log('Speech recognition started');
                                return true;
                            } catch (error) {
                                console.error('Error starting speech recognition:', error);
                                return false;
                            }
                        },
                        stop: () => {
                            try {
                                recognition.stop();
                                console.log('Speech recognition stopped');
                                return true;
                            } catch (error) {
                                console.error('Error stopping speech recognition:', error);
                                return false;
                            }
                        },
                        abort: () => {
                            try {
                                recognition.abort();
                                console.log('Speech recognition aborted');
                                return true;
                            } catch (error) {
                                console.error('Error aborting speech recognition:', error);
                                return false;
                            }
                        }
                    };
                } catch (error) {
                    console.error('Error setting up speech recognition:', error);
                    return {
                        start: () => {
                            alert('Speech recognition failed to initialize');
                            return false;
                        },
                        stop: () => {},
                        abort: () => {}
                    };
                }
            }

            // Fallback for unsupported browsers
            console.warn('Speech Recognition API not supported in this browser');
            return {
                start: () => {
                    alert('Speech recognition is not supported on this device or browser');
                    return false;
                },
                stop: () => {},
                abort: () => {}
            };
        };

        // MCP Command system
        const runMCPCommand = (command) => {
            console.log(`Running MCP command: ${command}`);
            // Log the command to IndexedDB
            db.table('mcp_logs').add({
                command,
                timestamp: new Date().toISOString()
            }).catch(err => console.error('Error logging MCP command:', err));

            // Handle different commands
            if (command === 'refresh_attendees') {
                return db.attendees.toArray();
            }

            return Promise.resolve(`Executed: ${command}`);
        };

        // Agent Lee - Main Orchestrator
        const AgentLee = {
            name: 'Agent Lee',
            role: 'Main System Orchestrator',
            voice: 'Emma',
            speak: (text) => speak(text, 'Emma'),
            handleMessage: async (message) => {
                if (message.toLowerCase().includes('refresh')) {
                    return runMCPCommand('refresh_attendees');
                }
                return `I'm Agent Lee, your family reunion coordinator. How can I help with the Hall Family Reunion?`;
            }
        };

        // Tim - Sales Agent (handling RSVPs/Invitations)
        const AgentTim = {
            name: 'Tim',
            role: 'Invitation Specialist',
            voice: 'Tom',
            speak: (text) => speak(text, 'Tom'),
            handleMessage: (message) => {
                return `I'm Tim, the invitation specialist. I'll help you track RSVPs and attendance.`;
            }
        };

        // Nicole - Showcase Agent (handling animations/visuals)
        const AgentNicole = {
            name: 'Nicole',
            role: 'Visual Designer',
            voice: 'Samantha',
            speak: (text) => speak(text, 'Samantha'),
            handleMessage: (message) => {
                return `I'm Nicole, your visual designer. I've created the balloon animations and color scheme for your family reunion.`;
            }
        };

        // Leonard - Resource Agent (handling activities/food)
        const AgentLeonard = {
            name: 'Leonard',
            role: 'Activity Coordinator',
            voice: 'Daniel',
            speak: (text) => speak(text, 'Daniel'),
            handleMessage: (message) => {
                return `I'm Leonard, your activity coordinator. I'll help organize all the fun activities and food for the reunion!`;
            }
        };

        // User authentication functions
        const signInAnonymously = async (userName) => {
            try {
                // For testing purposes, create a "fake" authenticated user
                // This avoids the need for Firebase Authentication
                const fakeUser = {
                    uid: 'user_' + new Date().getTime(),
                    displayName: userName,
                    isAnonymous: true
                };

                // Store the user in localStorage for persistence
                localStorage.setItem('fakeUser', JSON.stringify(fakeUser));

                // Add user to users collection in localStorage
                const users = LocalDB.getAll('users');
                users.push({
                    id: fakeUser.uid,
                    name: userName,
                    lastActive: new Date().toISOString(),
                    isOnline: true
                });
                localStorage.setItem('users', JSON.stringify(users));

                return fakeUser;
            } catch (error) {
                console.error('Error with fake sign in:', error);
                return null;
            }
        };

        // Set user status when they connect/disconnect
        const setUserStatus = (isOnline) => {
            // Get the fake user from localStorage
            const fakeUserStr = localStorage.getItem('fakeUser');
            if (fakeUserStr) {
                try {
                    const fakeUser = JSON.parse(fakeUserStr);

                    // Update user status in localStorage
                    const users = LocalDB.getAll('users');
                    const userIndex = users.findIndex(u => u.id === fakeUser.uid);

                    if (userIndex !== -1) {
                        users[userIndex].isOnline = isOnline;
                        users[userIndex].lastActive = new Date().toISOString();
                        localStorage.setItem('users', JSON.stringify(users));
                    }
                } catch (error) {
                    console.error('Error parsing fake user:', error);
                }
            }
        };

        // Helper function to get the current user
        const getCurrentUser = () => {
            // Try to get from localStorage
            const fakeUserStr = localStorage.getItem('fakeUser');
            if (fakeUserStr) {
                try {
                    return JSON.parse(fakeUserStr);
                } catch (error) {
                    console.error('Error parsing fake user:', error);
                }
            }
            return null;
        };

        // WebRTC connection handling
        let localPeerConnection = null;
        let localStream = null;

        // Setup WebRTC peer connection
        const setupPeerConnection = (userId) => {
            // Create a new RTCPeerConnection
            localPeerConnection = new RTCPeerConnection(peerConnectionConfig);

            // Add local stream tracks to the connection
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    localPeerConnection.addTrack(track, localStream);
                });
            }

            // Handle ICE candidates
            localPeerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // Send the ICE candidate to the remote peer via Firebase
                    const currentUser = firebase.auth().currentUser;
                    if (currentUser) {
                        rtcDb.ref(`calls/${userId}/candidates/${currentUser.uid}`).push({
                            candidate: event.candidate.toJSON(),
                            timestamp: firebase.database.ServerValue.TIMESTAMP
                        });
                    }
                }
            };

            // Handle remote stream
            localPeerConnection.ontrack = (event) => {
                const remoteVideo = document.getElementById('remote-video');
                if (remoteVideo && event.streams && event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                }
            };

            return localPeerConnection;
        };

        // Main React Components
        function App() {
            const [attendees, setAttendees] = React.useState([]);
            const [messages, setMessages] = React.useState([]);
            const [activities, setActivities] = React.useState([]);
            const [foods, setFoods] = React.useState([]);
            const [isAdmin, setIsAdmin] = React.useState(false);
            const [notification, setNotification] = React.useState(null);
            const [activeBalloons, setActiveBalloons] = React.useState([]);
            const [currentAgent, setCurrentAgent] = React.useState(AgentLee);
            const [isSpeaking, setIsSpeaking] = React.useState(false);
            const [speechOutput, setSpeechOutput] = React.useState('');
            const [darkMode, setDarkMode] = React.useState(false); // Dark mode state
            const [user, setUser] = React.useState(null); // Current user
            const [isAuthenticated, setIsAuthenticated] = React.useState(false); // Authentication state
            // Video chat states
            const [showVideoChat, setShowVideoChat] = React.useState(false);
            const [localStream, setLocalStream] = React.useState(null);
            const [chatType, setChatType] = React.useState('group');
            const [selectedMember, setSelectedMember] = React.useState('');
            const [isMicMuted, setIsMicMuted] = React.useState(false);
            const [isCameraOff, setIsCameraOff] = React.useState(false);
            const [isRemoteConnected, setIsRemoteConnected] = React.useState(false);
            const [isPushToTalkActive, setIsPushToTalkActive] = React.useState(false);
            const [isCallInProgress, setIsCallInProgress] = React.useState(false);
            const [callStatus, setCallStatus] = React.useState(''); // 'dialing', 'ringing', 'connected', 'ended'
            const [connectionState, setConnectionState] = React.useState('disconnected'); // 'disconnected', 'connecting', 'connected', 'failed'
            const [localSpeaking, setLocalSpeaking] = React.useState(false); // Whether the local user is speaking
            const [remoteSpeaking, setRemoteSpeaking] = React.useState(false); // Whether the remote user is speaking
            const [audioLevel, setAudioLevel] = React.useState(0); // Audio level for visualization

            // WebSocket states
            const [wsClient, setWsClient] = React.useState(null);
            const [wsConnected, setWsConnected] = React.useState(false);
            const [remoteStreams, setRemoteStreams] = React.useState({});
            const [roomId, setRoomId] = React.useState(null);

            // Messaging states
            const [messageMode, setMessageMode] = React.useState('public');
            const [privateMessageRecipient, setPrivateMessageRecipient] = React.useState('');

            // Speech recognition instance
            const [recognition, setRecognition] = React.useState(null);

            // Form states
            const [formData, setFormData] = React.useState({
                name: '',
                people: 1,
                location: '',
                message: '',
                privateMessage: '',
                address: '',
                activity: '',
                activityDesc: '',
                food: '',
                foodDesc: ''
            });

            // Initialize speech recognition
            React.useEffect(() => {
                const rec = setupSpeechRecognition((result) => {
                    setSpeechOutput(result);
                    handleVoiceCommand(result);
                });
                setRecognition(rec);

                // Generate balloons only around the perimeter of the screen
                const balloons = [];
                const totalBalloons = 15; // Reduced number of balloons

                for (let i = 0; i < totalBalloons; i++) {
                    // Determine if this balloon should be on the top/bottom or left/right edge
                    const isHorizontalEdge = i % 2 === 0;

                    let top, left;

                    if (isHorizontalEdge) {
                        // Place on top or bottom edge
                        top = (i % 4 === 0) ? '2vh' : '90vh'; // Either top or bottom
                        left = (Math.random() * 90 + 5) + 'vw'; // Random horizontal position
                    } else {
                        // Place on left or right edge
                        left = (i % 4 === 1) ? '2vw' : '95vw'; // Either left or right
                        top = (Math.random() * 80 + 5) + 'vh'; // Random vertical position
                    }

                    balloons.push({
                        id: i,
                        top: top,
                        left: left,
                        size: Math.random() * 12 + 15 + 'px', // Slightly smaller balloons
                        color: Math.random() > 0.6 ?
                               '#9370DB' :
                               Math.random() > 0.5 ? '#c2aae8' :
                               Math.random() > 0.5 ? '#ff9cee' : '#a3c4ff',
                        delay: Math.random() * 5 + 's',
                        duration: Math.random() * 4 + 10 + 's'
                    });
                }
                setActiveBalloons(balloons);

                // Generate a few sparkles only around the edges
                const sparkleContainer = document.createElement('div');
                sparkleContainer.className = 'sparkle-container';
                document.body.appendChild(sparkleContainer);

                for (let i = 0; i < 10; i++) { // Reduced from 30 to 10
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';

                    // Place sparkles only around the edges
                    if (i < 3) {
                        // Top edge
                        sparkle.style.top = '5vh';
                        sparkle.style.left = (Math.random() * 90 + 5) + 'vw';
                    } else if (i < 6) {
                        // Bottom edge
                        sparkle.style.top = '90vh';
                        sparkle.style.left = (Math.random() * 90 + 5) + 'vw';
                    } else if (i < 8) {
                        // Left edge
                        sparkle.style.top = (Math.random() * 80 + 10) + 'vh';
                        sparkle.style.left = '5vw';
                    } else {
                        // Right edge
                        sparkle.style.top = (Math.random() * 80 + 10) + 'vh';
                        sparkle.style.left = '95vw';
                    }

                    sparkle.style.animationDelay = Math.random() * 5 + 's';
                    sparkleContainer.appendChild(sparkle);
                }

                // Load data from IndexedDB
                loadData();

                // Add some example message data
                setMessages([
                    { id: 1, sender: 'Sarah', content: 'Hey everyone!', timestamp: new Date(Date.now() - 3600000).toISOString() },
                    { id: 2, sender: 'Me', content: 'I can\'t wait to see you all!', timestamp: new Date(Date.now() - 1800000).toISOString() }
                ]);
            }, []);

            // Load data from localStorage
            const loadData = async () => {
                try {
                    // Load initial data from localStorage

                    // Load attendees
                    const attendeeData = LocalDB.getAll('attendees');
                    setAttendees(attendeeData);

                    // Load messages
                    const messageData = LocalDB.getAll('messages');
                    // Sort messages by timestamp if available
                    messageData.sort((a, b) => {
                        if (!a.timestamp) return -1;
                        if (!b.timestamp) return 1;
                        return new Date(a.timestamp) - new Date(b.timestamp);
                    });
                    setMessages(messageData);

                    // Scroll to bottom of message board if it exists
                    const messageBoard = document.querySelector('.message-board');
                    if (messageBoard) {
                        messageBoard.scrollTop = messageBoard.scrollHeight;
                    }

                    // Load activities
                    const activityData = LocalDB.getAll('activities');
                    setActivities(activityData);

                    // Load foods
                    const foodData = LocalDB.getAll('foods');
                    setFoods(foodData);

                    // Set up storage event listener to update data when localStorage changes
                    const handleStorageChange = (e) => {
                        if (e.key === 'attendees') {
                            setAttendees(JSON.parse(e.newValue || '[]'));
                        } else if (e.key === 'messages') {
                            const newMessages = JSON.parse(e.newValue || '[]');
                            setMessages(newMessages);

                            // Scroll to bottom of message board if it exists
                            const messageBoard = document.querySelector('.message-board');
                            if (messageBoard) {
                                messageBoard.scrollTop = messageBoard.scrollHeight;
                            }
                        } else if (e.key === 'activities') {
                            setActivities(JSON.parse(e.newValue || '[]'));
                        } else if (e.key === 'foods') {
                            setFoods(JSON.parse(e.newValue || '[]'));
                        }
                    };

                    // Add storage event listener
                    window.addEventListener('storage', handleStorageChange);

                    // Clean up listener on unmount
                    return () => {
                        window.removeEventListener('storage', handleStorageChange);
                    };

                } catch (error) {
                    console.error('Error loading data from localStorage:', error);
                    showNotification('Error loading data', 'error');
                }
            };

            // Handle form changes
            const handleChange = (e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
            };

            // Handle attendance submission
            const handleAttendSubmit = async (e) => {
                e.preventDefault();

                // Check if user is authenticated
                if (!isAuthenticated) {
                    // Sign in anonymously with the name from the form
                    const name = formData.name.trim();
                    if (!name) {
                        showNotification('Please enter your name to register', 'error');
                        return;
                    }

                    const user = await signInAnonymously(name);
                    if (!user) {
                        showNotification('Error signing in. Please try again.', 'error');
                        return;
                    }

                    setUser(user);
                    setIsAuthenticated(true);
                    showNotification(`Welcome, ${name}!`, 'success');
                }

                try {
                    const name = formData.name.trim();
                    const location = formData.location.trim();

                    // Check for duplicate (same name and location)
                    const existingAttendeeSnapshot = await attendeesCollection
                        .where('name', '==', name)
                        .where('location', '==', location)
                        .get();

                    if (!existingAttendeeSnapshot.empty) {
                        showNotification(`${name} from ${location} has already registered. Please use a different name or location.`, 'error');
                        return;
                    }

                    const currentUser = getCurrentUser();
                    const attendee = {
                        name: name,
                        people: parseInt(formData.people),
                        location: location,
                        attending: true,
                        timestamp: new Date().toISOString(),
                        userId: currentUser?.uid || 'anonymous'
                    };

                    // Add to localStorage
                    const newAttendee = await attendeesCollection.add(attendee);

                    // Don't reset the name so it can be used in the message board
                    setFormData(prev => ({ ...prev, people: 1, location: '' }));

                    // Show notification
                    showNotification(`${attendee.name} has registered for the reunion!`, 'success');

                    // Send text notification to the registered person's phone
                    // This assumes they entered a phone number in the location field for demo purposes
                    // In a real app, you'd have a dedicated phone field
                    sendSMSNotification(`Thank you ${attendee.name}! You're registered for the Hall Family Reunion with ${attendee.people} ${attendee.people > 1 ? 'people' : 'person'} from ${attendee.location}.`);

                    // Agent speaks
                    AgentTim.speak(`Great news! ${attendee.name} from ${attendee.location} has registered for the reunion with ${attendee.people} ${attendee.people > 1 ? 'people' : 'person'}.`);

                    // Create fireworks celebration only near the submit button
                    createFireworks('submit-rsvp', 15);

                    // Check if this is an admin
                    if (name.toLowerCase().includes('admin')) {
                        setIsAdmin(true);
                        showNotification('Admin privileges granted!', 'success');
                    }
                } catch (error) {
                    console.error('Error adding attendee:', error);
                    showNotification('Error registering for the reunion', 'error');
                }
            };

            // Common emojis for quick access
            const commonEmojis = [
                "ðŸ˜€", "ðŸ˜‚", "â¤ï¸", "ðŸ‘", "ðŸ‘", "ðŸŽ‰", "ðŸ¥³", "ðŸ¤—",
                "ðŸ˜Š", "ðŸ™", "ðŸ‘‹", "ðŸ”¥", "ðŸ’¯", "â­", "ðŸŽ‚", "ðŸŽ",
                "ðŸ†", "ðŸ¥‡", "ðŸŽ¯", "ðŸŽµ", "ðŸŽ¸", "ðŸŽ¬", "ðŸ“¸", "ðŸ•",
                "ðŸ”", "ðŸ¦", "ðŸ°", "ðŸ·", "ðŸ¥‚", "â˜•", "ðŸŒˆ", "ðŸŒž",
                "ðŸŒ¹", "ðŸŒº", "ðŸŒ´", "ðŸŒŠ", "ðŸ–ï¸", "ðŸ¡", "ðŸš—", "âœˆï¸",
                "ðŸš€", "â°", "ðŸ“±", "ðŸ’»", "ðŸ“·", "ðŸŽ®", "ðŸŽ²", "ðŸŽ¨",
                "ðŸ“š", "ðŸ’ª", "ðŸƒâ€â™‚ï¸", "ðŸ§ "
            ];

            // Activity suggestions for dropdown
            const activitySuggestions = [
                // Backyard Games
                { category: "Backyard Games", name: "Cornhole (Bean Bag Toss)", description: "Easy to learn, fun for all ages, and great for friendly competition." },
                { category: "Backyard Games", name: "Giant Jenga", description: "Oversized blocks add excitement and suspense as the tower grows taller." },
                { category: "Backyard Games", name: "Backyard Connect Four", description: "A jumbo version of the classic game that's visually fun and interactive." },
                { category: "Backyard Games", name: "Bocce Ball", description: "Simple rules and suitable for large or small groups, bocce is a timeless outdoor favorite." },
                { category: "Backyard Games", name: "Croquet", description: "Set up a course and compete to see who can navigate their ball through the wickets first." },
                { category: "Backyard Games", name: "Spikeball", description: "Fast-paced and energetic, Spikeball is like a cross between volleyball and four square." },
                { category: "Backyard Games", name: "Tic Tac Toe (Yard Dice or Giant Board)", description: "Supersized pieces make this classic game more engaging outdoors." },
                { category: "Backyard Games", name: "Monster Toss or Ladder Toss", description: "Throw balls or beanbags at targets for points-easy to set up and play." },
                { category: "Backyard Games", name: "Relay Races & Obstacle Courses", description: "Set up simple races or challenges using cones, ropes, or household items." },
                { category: "Backyard Games", name: "Simon Says or Untangle", description: "Group games that encourage movement, teamwork, and lots of laughs." },

                // Board & Card Games
                { category: "Board & Card Games", name: "Uno", description: "Fast-paced and easy for all ages." },
                { category: "Board & Card Games", name: "Exploding Kittens", description: "Silly, quick, and family-friendly." },
                { category: "Board & Card Games", name: "Ticket to Ride", description: "Strategic but accessible, with a fun train theme." },
                { category: "Board & Card Games", name: "Codenames", description: "Great for larger groups and encourages teamwork." },
                { category: "Board & Card Games", name: "Jenga", description: "The classic tabletop version is just as fun as the giant outdoor one." },
                { category: "Board & Card Games", name: "Clue", description: "A mystery-solving game that gets everyone thinking." },
                { category: "Board & Card Games", name: "Sorry! and Trouble", description: "Simple, luck-based games that are easy for younger kids to join." },
                { category: "Board & Card Games", name: "Qwirkle", description: "Combines matching colors and shapes; easy to learn and play outdoors on a picnic table." },
                { category: "Board & Card Games", name: "Scattergories", description: "Creative and fast-paced word game-great for groups." },
                { category: "Board & Card Games", name: "Throw Throw Burrito", description: "Combines card play with soft-foam burrito throwing for active fun." },
                { category: "Board & Card Games", name: "Happy Salmon", description: "High-energy, quick, and perfect for family gatherings." }
            ];

            // Handle emoji selection
            const addEmojiToMessage = (emoji) => {
                setFormData(prev => ({
                    ...prev,
                    message: prev.message + emoji
                }));

                // Focus back on the message input
                document.getElementById('message').focus();
            };

            // Handle activity selection from dropdown
            const handleActivitySelect = (activity) => {
                // Set the form data with the selected activity
                setFormData(prev => ({
                    ...prev,
                    activity: activity.name,
                    activityDesc: activity.description
                }));

                // Show the selected activity in the input field
                document.getElementById('add-suggestion').value = activity.name;

                // Don't auto-submit - let the user review and submit manually
                showNotification(`Selected "${activity.name}". Click "Add" to submit.`, 'info');
            };

            // Handle message submission for the message board
            const handleMessageSubmit = async (e) => {
                e.preventDefault();
                if (!formData.message.trim()) return;

                // Check if user is authenticated
                if (!isAuthenticated) {
                    // Sign in anonymously with the name from the form
                    const name = formData.name.trim() || "Guest";
                    const user = await signInAnonymously(name);
                    if (user) {
                        setUser(user);
                        setIsAuthenticated(true);
                        showNotification(`Welcome, ${name}!`, 'success');
                    }
                }

                try {
                    // Use the name from the RSVP form, user profile, or "Guest" if not provided
                    const currentUser = getCurrentUser();
                    const sender = formData.name.trim() || currentUser?.displayName || "Guest";

                    const message = {
                        sender: sender,
                        content: formData.message,
                        timestamp: new Date().toISOString(),
                        userId: currentUser?.uid || 'anonymous',
                        recipient: null // null means public message
                    };

                    // Add to localStorage
                    await messagesCollection.add(message);

                    // Reset message form
                    setFormData(prev => ({ ...prev, message: '' }));

                    // Show notification
                    showNotification(`Message posted to the family board!`, 'success');

                    // Send text notification to admin
                    sendSMSNotification(`New family message from ${message.sender}: ${message.content.substring(0, 50)}${message.content.length > 50 ? '...' : ''}`);

                    // No fireworks for messages as requested
                } catch (error) {
                    console.error('Error adding message:', error);
                    showNotification('Error posting message', 'error');
                }
            };

            // Handle private message submission
            const handlePrivateMessageSubmit = async (e) => {
                e.preventDefault();
                if (!formData.privateMessage.trim() || !privateMessageRecipient) return;

                // Check if user is authenticated
                if (!isAuthenticated) {
                    // Sign in anonymously with the name from the form
                    const name = formData.name.trim() || "Guest";
                    const user = await signInAnonymously(name);
                    if (user) {
                        setUser(user);
                        setIsAuthenticated(true);
                        showNotification(`Welcome, ${name}!`, 'success');
                    }
                }

                try {
                    // Use the name from the RSVP form, user profile, or "Guest" if not provided
                    const currentUser = getCurrentUser();
                    const sender = formData.name.trim() || currentUser?.displayName || "Guest";

                    const message = {
                        sender: sender,
                        content: formData.privateMessage,
                        timestamp: new Date().toISOString(),
                        userId: currentUser?.uid || 'anonymous',
                        recipient: privateMessageRecipient
                    };

                    // Add to localStorage
                    await messagesCollection.add(message);

                    // Reset private message form
                    setFormData(prev => ({ ...prev, privateMessage: '' }));

                    // Show notification
                    showNotification(`Private message sent to ${privateMessageRecipient}!`, 'success');
                } catch (error) {
                    console.error('Error sending private message:', error);
                    showNotification('Error sending private message', 'error');
                }
            };

            // Handle activity submission
            const handleActivitySubmit = async (e) => {
                e.preventDefault();

                // Validate input
                if (!formData.activity || formData.activity.trim() === '') {
                    showNotification('Please enter an activity or select one from the dropdown', 'error');
                    return;
                }

                // Check if user is authenticated
                if (!isAuthenticated) {
                    // Sign in anonymously with the name from the form
                    const name = formData.name.trim() || "Guest";
                    const user = await signInAnonymously(name);
                    if (user) {
                        setUser(user);
                        setIsAuthenticated(true);
                        showNotification(`Welcome, ${name}!`, 'success');
                    }
                }

                try {
                    // Check for duplicate activity
                    const activityTitle = formData.activity.trim();

                    // Query localStorage for existing activity
                    const existingActivitySnapshot = await activitiesCollection
                        .where('title', '==', activityTitle)
                        .get();

                    if (!existingActivitySnapshot.empty) {
                        // If it already exists, just add a vote instead
                        const existingActivity = {
                            id: existingActivitySnapshot.docs[0].id,
                            ...existingActivitySnapshot.docs[0].data()
                        };

                        handleVote('activity', existingActivity.id);
                        showNotification(`"${activityTitle}" already exists. Added a vote instead!`, 'info');

                        // Reset form
                        setFormData(prev => ({ ...prev, activity: '', activityDesc: '' }));

                        // Reset dropdown
                        document.getElementById('activity-dropdown').value = '';

                        return;
                    }

                    // Create new activity
                    const currentUser = getCurrentUser();
                    const userId = currentUser?.uid || 'anonymous';
                    const activity = {
                        title: activityTitle,
                        description: formData.activityDesc || '',
                        votes: 1, // Start with 1 vote (the submitter's vote)
                        submitter: formData.name || currentUser?.displayName || 'Anonymous',
                        timestamp: new Date().toISOString(),
                        userId: userId,
                        voters: [userId] // Track who voted
                    };

                    // Add to localStorage
                    await activitiesCollection.add(activity);

                    // Reset form
                    setFormData(prev => ({ ...prev, activity: '', activityDesc: '' }));

                    // Reset dropdown
                    document.getElementById('activity-dropdown').value = '';

                    // Show notification
                    showNotification(`Activity "${activityTitle}" added with 1 vote!`, 'success');

                    // Agent speaks
                    AgentLeonard.speak(`New activity suggestion: ${activity.title}`);
                } catch (error) {
                    console.error('Error adding activity:', error);
                    showNotification('Error adding activity suggestion', 'error');
                }
            };

            // Handle food submission
            const handleFoodSubmit = async (e) => {
                e.preventDefault();
                try {
                    const food = {
                        title: formData.food,
                        description: formData.foodDesc,
                        votes: 0,
                        submitter: formData.name || 'Anonymous',
                        timestamp: new Date().toISOString()
                    };

                    const id = await db.foods.add(food);
                    setFoods([...foods, { ...food, id }]);

                    // Reset form
                    setFormData(prev => ({ ...prev, food: '', foodDesc: '' }));

                    // Show notification
                    showNotification(`Food suggestion added!`, 'success');

                    // Agent speaks
                    AgentLeonard.speak(`New food suggestion: ${food.title}`);
                } catch (error) {
                    console.error('Error adding food:', error);
                    showNotification('Error adding food suggestion', 'error');
                }
            };

            // Show notification
            const showNotification = (message, type = 'info') => {
                // Set the React state for the in-app notification
                setNotification({ message, type });
                setTimeout(() => setNotification(null), 5000);

                // Also use the global notification function for consistency
                globalNotify(message, type);
            };

            // Create fireworks animation near the submit button
            const createFireworks = (buttonId = 'submit-rsvp', count = 15) => {
                // Get the button's position
                const button = document.getElementById(buttonId);
                if (!button) return;

                const rect = button.getBoundingClientRect();
                const buttonCenterX = rect.left + rect.width / 2;
                const buttonTop = rect.top;

                const fireworksContainer = document.createElement('div');
                fireworksContainer.className = 'fireworks-container';
                fireworksContainer.style.position = 'fixed';
                fireworksContainer.style.top = '0';
                fireworksContainer.style.left = '0';
                fireworksContainer.style.width = '100%';
                fireworksContainer.style.height = '100%';
                fireworksContainer.style.pointerEvents = 'none';
                fireworksContainer.style.zIndex = '1000';
                document.body.appendChild(fireworksContainer);

                const colors = ['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff', '#ff9900', '#9900ff'];

                // Create fireworks only around the button area
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        const firework = document.createElement('div');
                        firework.className = 'firework';

                        // Position fireworks around the button
                        const offsetX = (Math.random() - 0.5) * 200; // -100px to +100px from button center
                        const offsetY = -Math.random() * 100 - 50; // 50-150px above the button

                        firework.style.left = (buttonCenterX + offsetX) + 'px';
                        firework.style.top = (buttonTop + offsetY) + 'px';
                        firework.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                        firework.style.boxShadow = `0 0 10px 5px ${firework.style.backgroundColor}`;

                        fireworksContainer.appendChild(firework);

                        // Remove firework after animation completes
                        setTimeout(() => {
                            firework.remove();
                        }, 1000);
                    }, i * 100); // Stagger the fireworks
                }

                // Remove container after all fireworks are done
                setTimeout(() => {
                    fireworksContainer.remove();
                }, count * 100 + 1500);
            };

            // Handle vote
            const handleVote = async (type, id) => {
                // Check if user is authenticated
                if (!isAuthenticated) {
                    // Sign in anonymously with the name from the form
                    const name = formData.name.trim() || "Guest";
                    const user = await signInAnonymously(name);
                    if (user) {
                        setUser(user);
                        setIsAuthenticated(true);
                        showNotification(`Welcome, ${name}!`, 'success');
                    } else {
                        showNotification('Please sign in to vote', 'error');
                        return;
                    }
                }

                const currentUser = getCurrentUser();
                const userId = currentUser?.uid || 'anonymous';

                try {
                    if (type === 'activity') {
                        // Get the activity document
                        const activityRef = activitiesCollection.doc(id);
                        const activityDoc = await activityRef.get();

                        if (activityDoc.exists) {
                            const activityData = activityDoc.data();
                            const voters = activityData.voters || [];

                            // Check if user already voted
                            if (voters.includes(userId)) {
                                showNotification('You have already voted for this activity', 'info');
                                return;
                            }

                            // Update in localStorage
                            const activities = LocalDB.getAll('activities');
                            const activityIndex = activities.findIndex(a => a.id === id);

                            if (activityIndex !== -1) {
                                const activity = activities[activityIndex];
                                const voters = activity.voters || [];

                                // Update the activity
                                activities[activityIndex] = {
                                    ...activity,
                                    votes: (activity.votes || 0) + 1,
                                    voters: [...voters, userId]
                                };

                                // Save back to localStorage
                                localStorage.setItem('activities', JSON.stringify(activities));
                            }

                            showNotification(`Voted for "${activityData.title}"!`, 'success');
                        }
                    } else if (type === 'food') {
                        // Get the food document
                        const foodRef = foodsCollection.doc(id);
                        const foodDoc = await foodRef.get();

                        if (foodDoc.exists) {
                            const foodData = foodDoc.data();
                            const voters = foodData.voters || [];

                            // Check if user already voted
                            if (voters.includes(userId)) {
                                showNotification('You have already voted for this food', 'info');
                                return;
                            }

                            // Update in localStorage
                            const foods = LocalDB.getAll('foods');
                            const foodIndex = foods.findIndex(f => f.id === id);

                            if (foodIndex !== -1) {
                                const food = foods[foodIndex];
                                const voters = food.voters || [];

                                // Update the food
                                foods[foodIndex] = {
                                    ...food,
                                    votes: (food.votes || 0) + 1,
                                    voters: [...voters, userId]
                                };

                                // Save back to localStorage
                                localStorage.setItem('foods', JSON.stringify(foods));
                            }

                            showNotification(`Voted for "${foodData.title}"!`, 'success');
                        }
                    }
                } catch (error) {
                    console.error(`Error voting for ${type}:`, error);
                    showNotification(`Error voting for ${type}`, 'error');
                }
            };

            // Handle voice command
            const handleVoiceCommand = (command) => {
                if (!command) return;

                const cmd = command.toLowerCase();

                if (cmd.includes('submit') || cmd.includes('register') || cmd.includes('rsvp')) {
                    document.getElementById('submit-rsvp').click();
                } else if (cmd.includes('message') || cmd.includes('chat') || cmd.includes('send')) {
                    // If it's a message command, set the message input and send it
                    document.getElementById('message').value = cmd;
                    setFormData(prev => ({ ...prev, message: cmd }));
                    document.getElementById('send-message').click();
                } else if (cmd.includes('suggest') || cmd.includes('activity')) {
                    document.getElementById('add-suggestion').focus();
                } else {
                    // Use the voice command as a message for the family board
                    document.getElementById('message').value = cmd;
                    setFormData(prev => ({ ...prev, message: cmd }));
                    document.getElementById('send-message').click();
                }
            };

            // Start listening with improved mobile support
            const startListening = (mode = 'public') => {
                console.log('Starting voice recognition for mode:', mode);

                if (recognition) {
                    try {
                        // Play a sound to indicate listening started
                        try {
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const oscillator = audioContext.createOscillator();
                            const gainNode = audioContext.createGain();

                            oscillator.type = 'sine';
                            oscillator.frequency.value = 880; // A5 note (high)
                            gainNode.gain.value = 0.1; // Low volume

                            oscillator.connect(gainNode);
                            gainNode.connect(audioContext.destination);

                            oscillator.start();
                            setTimeout(() => {
                                oscillator.stop();
                                audioContext.close();
                            }, 200);
                        } catch (error) {
                            console.error('Error playing recognition start sound:', error);
                        }

                        // Update UI to show we're listening
                        setSpeechOutput('Listening...');
                        setIsSpeaking(true);

                        // Show visual feedback
                        showNotification('Listening for voice input...', 'info');

                        // Set the mode for the recognition result handler
                        recognition.onresult = (event) => {
                            // Get the most recent result
                            const lastResultIndex = event.results.length - 1;
                            const result = event.results[lastResultIndex][0].transcript;

                            console.log('Speech recognition result:', result);
                            setSpeechOutput(result);

                            // Only process final results
                            if (event.results[lastResultIndex].isFinal) {
                                if (mode === 'private') {
                                    // Set the private message input
                                    setFormData(prev => ({ ...prev, privateMessage: result }));

                                    // Focus the private message input
                                    const privateMessageInput = document.getElementById('private-message');
                                    if (privateMessageInput) {
                                        privateMessageInput.focus();
                                    }
                                } else {
                                    // Set the public message input
                                    setFormData(prev => ({ ...prev, message: result }));

                                    // Focus the message input
                                    const messageInput = document.getElementById('message');
                                    if (messageInput) {
                                        messageInput.focus();
                                    }

                                    // Process voice commands
                                    handleVoiceCommand(result);
                                }
                            }
                        };

                        // Handle recognition end
                        recognition.onend = () => {
                            console.log('Speech recognition ended');
                            setSpeechOutput('');
                            setIsSpeaking(false);
                        };

                        // Start recognition
                        recognition.start();
                        console.log('Speech recognition started');
                    } catch (error) {
                        console.error('Error starting speech recognition:', error);
                        setSpeechOutput('Error starting voice recognition');
                        setIsSpeaking(false);
                        showNotification('Error starting voice recognition. Please try again.', 'error');
                    }
                } else {
                    console.warn('Speech recognition not available');
                    showNotification('Voice recognition is not available on this device or browser', 'error');

                    // Try to initialize recognition again
                    const rec = setupSpeechRecognition((result) => {
                        setSpeechOutput(result);
                        handleVoiceCommand(result);
                    });

                    if (rec) {
                        setRecognition(rec);
                        showNotification('Voice recognition initialized. Please try again.', 'info');
                    }
                }
            };

            // Stop speaking
            const stopSpeaking = () => {
                window.speechSynthesis.cancel();
                setIsSpeaking(false);
            };

            // Change current agent
            const changeAgent = (agent) => {
                setCurrentAgent(agent);
                agent.speak(`Hello, I'm ${agent.name}, the ${agent.role}.`);
            };

            // Toggle dark mode
            const toggleDarkMode = () => {
                const newDarkMode = !darkMode;
                setDarkMode(newDarkMode);

                // Apply dark mode class to body
                if (newDarkMode) {
                    document.body.classList.add('dark-mode');
                } else {
                    document.body.classList.remove('dark-mode');
                }

                // Save preference to localStorage
                localStorage.setItem('darkMode', newDarkMode);
            };

            // Sign out user
            const signOut = async () => {
                try {
                    // Set user status to offline
                    await setUserStatus(false);

                    // Remove fake user from localStorage
                    localStorage.removeItem('fakeUser');

                    // Reset state
                    setUser(null);
                    setIsAuthenticated(false);
                    setIsAdmin(false);

                    showNotification('You have been signed out', 'info');
                } catch (error) {
                    console.error('Error signing out:', error);
                    showNotification('Error signing out', 'error');
                }
            };



            // Clear the entire attendee list (admin only)
            const clearAttendeeList = async () => {
                if (!isAdmin) return;

                if (window.confirm('Are you sure you want to clear the entire RSVP list? This cannot be undone.')) {
                    try {
                        // Clear attendees in localStorage
                        localStorage.setItem('attendees', '[]');

                        // Update state
                        setAttendees([]);

                        showNotification('RSVP list has been cleared', 'success');
                    } catch (error) {
                        console.error('Error clearing attendee list:', error);
                        showNotification('Error clearing RSVP list', 'error');
                    }
                }
            };

            // Remove a single attendee (admin only)
            const removeAttendee = async (id) => {
                if (!isAdmin) return;

                try {
                    // Remove from localStorage
                    const attendees = LocalDB.getAll('attendees');
                    const updatedAttendees = attendees.filter(a => a.id !== id);
                    localStorage.setItem('attendees', JSON.stringify(updatedAttendees));
                    setAttendees(updatedAttendees);

                    showNotification('Attendee removed', 'success');
                } catch (error) {
                    console.error('Error removing attendee:', error);
                    showNotification('Error removing attendee', 'error');
                }
            };

            // Remove an activity (admin only)
            const removeActivity = async (id) => {
                if (!isAdmin) return;

                try {
                    // Remove from localStorage
                    const activities = LocalDB.getAll('activities');
                    const updatedActivities = activities.filter(a => a.id !== id);
                    localStorage.setItem('activities', JSON.stringify(updatedActivities));
                    setActivities(updatedActivities);

                    showNotification('Activity removed', 'success');
                } catch (error) {
                    console.error('Error removing activity:', error);
                    showNotification('Error removing activity', 'error');
                }
            };

            // Add emoji to private message
            const addEmojiToPrivateMessage = (emoji) => {
                setFormData(prev => ({
                    ...prev,
                    privateMessage: prev.privateMessage + emoji
                }));

                // Focus back on the private message input
                document.getElementById('private-message').focus();
            };



            // Handle call button click
            const handleCallButtonClick = () => {
                if (!selectedMember) {
                    showNotification('Please select a family member to call', 'error');
                    return;
                }

                // Set call status to dialing
                setCallStatus('dialing');
                setIsCallInProgress(true);

                // Show notification
                showNotification(`Calling ${selectedMember}...`, 'info');

                // Check if we have a WebSocket connection
                if (wsClient && wsConnected) {
                    console.log('Using WebSocket for video call');

                    // Request camera and microphone access
                    navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        },
                        audio: true
                    })
                    .then(stream => {
                        console.log('Got local media stream:', stream.getTracks());
                        setLocalStream(stream);

                        // Set the stream to the local video element
                        const videoElement = document.getElementById('local-video');
                        if (videoElement) {
                            videoElement.srcObject = stream;
                            videoElement.muted = true; // Mute local video to prevent feedback
                            videoElement.play().catch(e => console.error('Error playing local video:', e));
                        }

                        // Add the stream to the WebSocket client
                        wsClient.addLocalStream(stream);

                        // Create a room for the call
                        wsClient.createRoom('private');

                        // Set call status to ringing
                        setCallStatus('ringing');
                        showNotification(`${selectedMember}'s phone is ringing...`, 'info');

                        // Simulate another user joining the room (for testing)
                        setTimeout(() => {
                            // This simulates the server's response when another user joins
                            const simulatedUserId = 'simulated-user-' + Date.now();

                            // Call the onUserJoined callback directly
                            if (wsClient.onUserJoinedCallback) {
                                wsClient.onUserJoinedCallback(simulatedUserId, 'private');
                            }

                            // Create a simulated remote stream
                            const fakeStream = createSimulatedStream();

                            // Call the onTrack callback directly
                            if (wsClient.onTrackCallback) {
                                wsClient.onTrackCallback(simulatedUserId, fakeStream);
                            }
                        }, 2000);
                    })
                    .catch(error => {
                        console.error('Error accessing camera or microphone:', error);
                        showNotification('Error accessing camera or microphone. Using simulated mode.', 'error');

                        // Fall back to simulated mode
                        simulateCall();
                    });
                } else {
                    console.log('WebSocket not connected, using simulated mode');
                    // Fall back to simulated mode if WebSocket is not connected
                    simulateCall();
                }
            };

            // Simulate a call (fallback when WebSocket is not available)
            const simulateCall = () => {
                // Simulate call connection process
                setTimeout(() => {
                    setCallStatus('ringing');
                    showNotification(`${selectedMember}'s phone is ringing...`, 'info');

                    // Simulate answer after a delay
                    setTimeout(() => {
                        setCallStatus('connected');
                        setIsRemoteConnected(true);
                        showNotification(`${selectedMember} answered the call!`, 'success');

                        // Create a simulated video stream for the remote user
                        const remoteVideo = document.getElementById('remote-video');
                        if (remoteVideo) {
                            // Use the existing createSimulatedStream function
                            const fakeStream = createSimulatedStream();
                            remoteVideo.srcObject = fakeStream;
                            remoteVideo.play().catch(e => console.error('Error playing remote video:', e));
                        }
                    }, 3000); // 3 seconds to answer
                }, 2000); // 2 seconds to start ringing
            };

            // Test media devices before starting a call
            const testMediaDevices = async () => {
                try {
                    // Create a modal dialog for the test
                    const modal = document.createElement('div');
                    modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                    modal.innerHTML = `
                        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-lg w-full mx-4">
                            <h3 class="text-xl font-bold mb-4 text-gray-900 dark:text-white">Camera & Microphone Test</h3>
                            <div class="mb-4">
                                <div class="relative rounded-lg overflow-hidden bg-gray-200 dark:bg-gray-700" style="height: 240px;">
                                    <video id="test-video" autoplay muted playsinline class="w-full h-full object-cover"></video>
                                    <div id="no-camera-message" class="absolute inset-0 flex items-center justify-center text-gray-500 dark:text-gray-400 hidden">
                                        <div class="text-center">
                                            <i class="fas fa-video-slash text-4xl mb-2"></i>
                                            <p>No camera detected</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="mb-4">
                                <p class="text-sm text-gray-600 dark:text-gray-300 mb-2">Microphone Level:</p>
                                <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4">
                                    <div id="audio-level-indicator" class="bg-green-500 h-4 rounded-full" style="width: 0%"></div>
                                </div>
                            </div>
                            <div class="mb-4">
                                <p class="text-sm text-gray-600 dark:text-gray-300" id="devices-info">Checking available devices...</p>
                            </div>
                            <div class="flex justify-end">
                                <button id="close-test" class="bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded-lg">
                                    Close
                                </button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);

                    // Get elements
                    const testVideo = document.getElementById('test-video');
                    const noCameraMessage = document.getElementById('no-camera-message');
                    const audioLevelIndicator = document.getElementById('audio-level-indicator');
                    const devicesInfo = document.getElementById('devices-info');
                    const closeButton = document.getElementById('close-test');

                    // Close button event
                    closeButton.addEventListener('click', () => {
                        // Stop all tracks
                        if (testStream) {
                            testStream.getTracks().forEach(track => track.stop());
                        }

                        // Remove the modal
                        document.body.removeChild(modal);
                    });

                    // Get available devices
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    const audioDevices = devices.filter(device => device.kind === 'audioinput');

                    devicesInfo.innerHTML = `
                        <p><strong>Available Devices:</strong></p>
                        <p>Cameras: ${videoDevices.length}</p>
                        <p>Microphones: ${audioDevices.length}</p>
                    `;

                    // Try to get media stream
                    let testStream;
                    try {
                        testStream = await navigator.mediaDevices.getUserMedia({
                            video: true,
                            audio: true
                        });

                        // Set video stream
                        testVideo.srcObject = testStream;

                        // Set up audio level detection
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const analyser = audioContext.createAnalyser();
                        const microphone = audioContext.createMediaStreamSource(testStream);
                        microphone.connect(analyser);
                        analyser.fftSize = 256;
                        const bufferLength = analyser.frequencyBinCount;
                        const dataArray = new Uint8Array(bufferLength);

                        // Update audio level indicator
                        const updateAudioLevel = () => {
                            if (!document.body.contains(modal)) return;

                            analyser.getByteFrequencyData(dataArray);
                            let sum = 0;
                            for (let i = 0; i < bufferLength; i++) {
                                sum += dataArray[i];
                            }
                            const average = sum / bufferLength;
                            const level = Math.min(100, average * 3); // Scale up for better visibility

                            audioLevelIndicator.style.width = `${level}%`;

                            // Change color based on level
                            if (level < 10) {
                                audioLevelIndicator.className = 'bg-red-500 h-4 rounded-full';
                            } else if (level < 30) {
                                audioLevelIndicator.className = 'bg-yellow-500 h-4 rounded-full';
                            } else {
                                audioLevelIndicator.className = 'bg-green-500 h-4 rounded-full';
                            }

                            requestAnimationFrame(updateAudioLevel);
                        };

                        updateAudioLevel();

                        // Show guidance
                        showNotification('Try speaking to test your microphone', 'info');

                    } catch (error) {
                        console.error('Error accessing media devices:', error);

                        // Show error message
                        if (error.name === 'NotAllowedError') {
                            devicesInfo.innerHTML = `
                                <p class="text-red-500"><strong>Permission Denied</strong></p>
                                <p>Please allow access to your camera and microphone in your browser settings.</p>
                                <p class="mt-2">Instructions:</p>
                                <ol class="list-decimal ml-5">
                                    <li>Click the camera/microphone icon in your address bar</li>
                                    <li>Select "Allow" for both camera and microphone</li>
                                    <li>Refresh the page and try again</li>
                                </ol>
                            `;
                        } else if (error.name === 'NotFoundError') {
                            devicesInfo.innerHTML = `
                                <p class="text-red-500"><strong>No Devices Found</strong></p>
                                <p>We couldn't detect a camera or microphone on your device.</p>
                                <p>Please connect a webcam or microphone and try again.</p>
                            `;
                        } else {
                            devicesInfo.innerHTML = `
                                <p class="text-red-500"><strong>Error: ${error.name}</strong></p>
                                <p>${error.message}</p>
                            `;
                        }

                        // Show no camera message
                        noCameraMessage.classList.remove('hidden');
                    }

                } catch (error) {
                    console.error('Error in media device test:', error);
                    showNotification('Error testing media devices', 'error');
                }
            };

            // End call
            const endCall = () => {
                setCallStatus('ended');
                setIsCallInProgress(false);
                setIsRemoteConnected(false);

                // Show notification
                showNotification('Call ended', 'info');

                // Clear remote video
                const remoteVideo = document.getElementById('remote-video');
                if (remoteVideo && remoteVideo.srcObject) {
                    const tracks = remoteVideo.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    remoteVideo.srcObject = null;
                }

                // Stop local stream if it exists
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    setLocalStream(null);

                    // Clear local video
                    const localVideo = document.getElementById('local-video');
                    if (localVideo) {
                        localVideo.srcObject = null;
                    }
                }

                // If we're using WebSockets, leave the room
                if (wsClient && roomId) {
                    // In a real implementation, we would send a message to leave the room
                    // For now, we'll just reset the room ID
                    setRoomId(null);
                }
            };

            // Create a simulated remote video stream
            const createSimulatedStream = () => {
                // Create a canvas element to generate a fake video stream
                const canvas = document.createElement('canvas');
                canvas.width = 320;
                canvas.height = 240;

                // Get the canvas context for drawing
                const ctx = canvas.getContext('2d');

                // Draw a placeholder image/avatar
                const drawPlaceholder = () => {
                    // Clear canvas
                    ctx.fillStyle = '#f3f4f6';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw circle for head
                    ctx.fillStyle = '#9333ea';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2, canvas.height/2 - 30, 50, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw body
                    ctx.fillRect(canvas.width/2 - 40, canvas.height/2 + 20, 80, 80);

                    // Draw text
                    ctx.fillStyle = 'white';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(selectedMember || 'Family Member', canvas.width/2, canvas.height/2 - 30);

                    // Add timestamp to show movement
                    const now = new Date();
                    ctx.fillStyle = '#4b5563';
                    ctx.font = '12px Arial';
                    ctx.fillText(now.toLocaleTimeString(), canvas.width/2, canvas.height - 10);
                };

                // Start animation loop
                setInterval(drawPlaceholder, 1000);
                drawPlaceholder();

                // Create a stream from the canvas
                const stream = canvas.captureStream(30); // 30 FPS

                // Create a silent audio track (properly configured to avoid buzzing)
                let audioContext;
                let audioTrack;

                try {
                    // Initialize audio context with proper options
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 44100
                    });

                    // Create a silent oscillator (0 frequency)
                    const oscillator = audioContext.createOscillator();
                    oscillator.frequency.value = 0; // Set to 0 Hz to create silence

                    // Create a gain node and set it to 0 (mute)
                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = 0;

                    // Connect oscillator to gain node
                    oscillator.connect(gainNode);

                    // Connect gain node to destination
                    const dst = gainNode.connect(audioContext.createMediaStreamDestination());

                    // Start the oscillator
                    oscillator.start();

                    // Get the audio track
                    audioTrack = dst.stream.getAudioTracks()[0];

                    // Add the audio track to the stream
                    stream.addTrack(audioTrack);

                    console.log('Silent audio track created successfully for simulated stream');
                } catch (error) {
                    console.error('Error creating silent audio track for simulated stream:', error);
                }

                return stream;
            };

            // Start video chat
            const startVideoChat = async (type = 'group') => {
                try {
                    // Check if user is authenticated
                    if (!isAuthenticated) {
                        // Sign in anonymously with the name from the form
                        const name = formData.name.trim() || "Guest";
                        const user = await signInAnonymously(name);
                        if (user) {
                            setUser(user);
                            setIsAuthenticated(true);
                            showNotification(`Welcome, ${name}!`, 'success');
                        } else {
                            showNotification('Please sign in to start a video chat', 'error');
                            return;
                        }
                    }

                    // Show the video chat UI
                    setShowVideoChat(true);
                    setChatType(type || 'group');

                    // Request access to webcam and microphone based on type
                    const constraints = {
                        video: type !== 'audio' && type !== 'cb',
                        audio: true
                    };

                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    setLocalStream(stream);
                    // Create a new variable instead of modifying the read-only one
                    const newLocalStream = stream;
                    setShowVideoChat(true);

                    // Reset states
                    setIsMicMuted(false);
                    setIsCameraOff(false);
                    setIsRemoteConnected(false);
                    setConnectionState('connecting');

                    // Set the stream to the video element
                    const videoElement = document.getElementById('local-video');
                    if (videoElement && stream.getVideoTracks().length > 0) {
                        videoElement.srcObject = stream;
                    }

                    // Create a call room in localStorage
                    const currentUser = getCurrentUser();
                    if (currentUser) {
                        const callId = type === 'group' ? 'group-call' : `private-call-${currentUser.uid}`;

                        // Create or update call room
                        const call = {
                            id: callId,
                            type: type,
                            createdBy: currentUser.uid,
                            createdAt: new Date().toISOString(),
                            active: true,
                            participants: {
                                [currentUser.uid]: {
                                    name: currentUser.displayName || formData.name || 'Guest',
                                    joinedAt: new Date().toISOString(),
                                    isActive: true
                                }
                            }
                        };

                        // Store in localStorage
                        const calls = LocalDB.getAll('calls');
                        const existingCallIndex = calls.findIndex(c => c.id === callId);

                        if (existingCallIndex !== -1) {
                            calls[existingCallIndex] = call;
                        } else {
                            calls.push(call);
                        }

                        localStorage.setItem('calls', JSON.stringify(calls));

                        // For demo purposes, we'll simulate a peer connection
                        // In a real app, you would use WebRTC with a signaling server

                        // Create a simulated remote video stream
                        const createSimulatedStream = () => {
                            // Create a canvas element to generate a fake video stream
                            const canvas = document.createElement('canvas');
                            canvas.width = 320;
                            canvas.height = 240;

                            // Get the canvas context for drawing
                            const ctx = canvas.getContext('2d');

                            // Draw a placeholder image/avatar
                            const drawPlaceholder = () => {
                                // Clear canvas
                                ctx.fillStyle = '#f3f4f6';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);

                                // Draw circle for head
                                ctx.fillStyle = '#9333ea';
                                ctx.beginPath();
                                ctx.arc(canvas.width/2, canvas.height/2 - 30, 50, 0, Math.PI * 2);
                                ctx.fill();

                                // Draw body
                                ctx.fillRect(canvas.width/2 - 40, canvas.height/2 + 20, 80, 80);

                                // Draw text
                                ctx.fillStyle = 'white';
                                ctx.font = '20px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('Family Member', canvas.width/2, canvas.height/2 - 30);

                                // Add timestamp to show movement
                                const now = new Date();
                                ctx.fillStyle = '#4b5563';
                                ctx.font = '12px Arial';
                                ctx.fillText(now.toLocaleTimeString(), canvas.width/2, canvas.height - 10);
                            };

                            // Start animation loop
                            setInterval(drawPlaceholder, 1000);
                            drawPlaceholder();

                            // Create a stream from the canvas
                            const stream = canvas.captureStream(30); // 30 FPS

                            // Create a silent audio track (properly configured to avoid buzzing)
                            let audioContext;
                            let audioTrack;

                            try {
                                // Initialize audio context with proper options
                                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                                    latencyHint: 'interactive',
                                    sampleRate: 44100
                                });

                                // Create a silent oscillator (0 frequency)
                                const oscillator = audioContext.createOscillator();
                                oscillator.frequency.value = 0; // Set to 0 Hz to create silence

                                // Create a gain node and set it to 0 (mute)
                                const gainNode = audioContext.createGain();
                                gainNode.gain.value = 0;

                                // Connect oscillator to gain node
                                oscillator.connect(gainNode);

                                // Connect gain node to destination
                                const dst = gainNode.connect(audioContext.createMediaStreamDestination());

                                // Start the oscillator
                                oscillator.start();

                                // Get the audio track
                                audioTrack = dst.stream.getAudioTracks()[0];

                                // Add the audio track to the stream
                                stream.addTrack(audioTrack);

                                console.log('Silent audio track created successfully');
                            } catch (error) {
                                console.error('Error creating silent audio track:', error);
                            }

                            return stream;
                        };

                        // Simulate a remote user joining after a short delay
                        setTimeout(() => {
                            // Create a simulated remote participant
                            const simulatedParticipant = {
                                id: 'simulated-user-' + Date.now(),
                                name: 'Family Member',
                                joinedAt: new Date().toISOString(),
                                isActive: true
                            };

                            // Update the call with the new participant
                            const calls = LocalDB.getAll('calls');
                            const callIndex = calls.findIndex(c => c.id === callId);

                            if (callIndex !== -1) {
                                calls[callIndex].participants[simulatedParticipant.id] = simulatedParticipant;
                                localStorage.setItem('calls', JSON.stringify(calls));

                                // Create a simulated video stream
                                const fakeStream = createSimulatedStream();

                                // Set the stream to the remote video element
                                const remoteVideo = document.getElementById('remote-video');
                                if (remoteVideo) {
                                    remoteVideo.srcObject = fakeStream;
                                    remoteVideo.play().catch(e => console.error('Error playing remote video:', e));
                                }

                                // Update UI to show connected state
                                setIsRemoteConnected(true);
                                showNotification(`${simulatedParticipant.name} has joined the chat!`, 'success');
                            }
                        }, 2000); // 2 second delay
                    }

                    showNotification(`${type.charAt(0).toUpperCase() + type.slice(1)} chat started!`, 'success');
                } catch (error) {
                    console.error('Error starting video chat:', error);
                    showNotification('Error accessing camera or microphone. Please check permissions.', 'error');
                }
            };

            // Stop video chat
            const stopVideoChat = () => {
                // Stop media tracks
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    setLocalStream(null);
                }

                // Update UI state
                setShowVideoChat(false);
                setIsRemoteConnected(false);
                setConnectionState('disconnected');

                // Update call status in localStorage
                const currentUser = getCurrentUser();
                if (currentUser) {
                    const callId = chatType === 'group' ? 'group-call' : `private-call-${currentUser.uid}`;

                    // Get calls from localStorage
                    const calls = LocalDB.getAll('calls');
                    const callIndex = calls.findIndex(c => c.id === callId);

                    if (callIndex !== -1) {
                        // Update participant status
                        if (calls[callIndex].participants[currentUser.uid]) {
                            calls[callIndex].participants[currentUser.uid].isActive = false;
                            calls[callIndex].participants[currentUser.uid].leftAt = new Date().toISOString();
                        }

                        // Save back to localStorage
                        localStorage.setItem('calls', JSON.stringify(calls));
                    }
                }

                showNotification('Chat session ended', 'info');
            };

            // Toggle microphone
            const toggleMicrophone = () => {
                if (localStream) {
                    const audioTracks = localStream.getAudioTracks();
                    if (audioTracks.length > 0) {
                        const track = audioTracks[0];
                        track.enabled = !track.enabled;
                        setIsMicMuted(!track.enabled);
                        showNotification(`Microphone ${track.enabled ? 'unmuted' : 'muted'}`, 'info');
                    }
                }
            };

            // Toggle camera
            const toggleCamera = () => {
                if (localStream) {
                    const videoTracks = localStream.getVideoTracks();
                    if (videoTracks.length > 0) {
                        const track = videoTracks[0];
                        track.enabled = !track.enabled;
                        setIsCameraOff(!track.enabled);
                        showNotification(`Camera ${track.enabled ? 'turned on' : 'turned off'}`, 'info');
                    }
                }
            };

            // Push-to-talk functionality with improved mobile support
            const startPushToTalk = () => {
                console.log('Starting push-to-talk');
                setIsPushToTalkActive(true);

                if (localStream) {
                    try {
                        // Get audio tracks
                        const audioTracks = localStream.getAudioTracks();

                        if (audioTracks.length > 0) {
                            // Enable the audio track
                            audioTracks[0].enabled = true;

                            // Apply constraints for better audio quality
                            if (audioTracks[0].applyConstraints) {
                                const constraints = {
                                    echoCancellation: true,
                                    noiseSuppression: true,
                                    autoGainControl: true
                                };

                                audioTracks[0].applyConstraints(constraints)
                                    .catch(e => console.warn('Could not apply audio constraints:', e));
                            }

                            console.log('Audio track enabled for push-to-talk');
                        } else {
                            console.warn('No audio tracks found in local stream');
                            showNotification('No microphone available for push-to-talk', 'warning');
                        }
                    } catch (error) {
                        console.error('Error enabling audio for push-to-talk:', error);
                    }
                } else {
                    console.warn('No local stream available for push-to-talk');

                    // Try to get audio-only stream if no stream exists
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(stream => {
                            console.log('Got audio stream for push-to-talk');
                            setLocalStream(stream);
                        })
                        .catch(error => {
                            console.error('Error getting audio stream for push-to-talk:', error);
                            showNotification('Could not access microphone for push-to-talk', 'error');
                        });
                }

                // Play a subtle sound to indicate transmission started
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.type = 'sine';
                    oscillator.frequency.value = 440; // A4 note
                    gainNode.gain.value = 0.1; // Low volume

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.start();
                    setTimeout(() => {
                        oscillator.stop();
                        audioContext.close();
                    }, 100);
                } catch (error) {
                    console.error('Error playing push-to-talk sound:', error);
                }

                showNotification('Transmitting audio...', 'info');
            };

            const stopPushToTalk = () => {
                console.log('Stopping push-to-talk');
                setIsPushToTalkActive(false);

                if (localStream) {
                    try {
                        const audioTracks = localStream.getAudioTracks();

                        if (audioTracks.length > 0) {
                            // Disable the audio track
                            audioTracks[0].enabled = false;
                            console.log('Audio track disabled for push-to-talk');
                        }
                    } catch (error) {
                        console.error('Error disabling audio for push-to-talk:', error);
                    }
                }

                // Play a subtle sound to indicate transmission ended
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.type = 'sine';
                    oscillator.frequency.value = 220; // A3 note (lower)
                    gainNode.gain.value = 0.1; // Low volume

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.start();
                    setTimeout(() => {
                        oscillator.stop();
                        audioContext.close();
                    }, 100);
                } catch (error) {
                    console.error('Error playing push-to-talk end sound:', error);
                }
            };

            // Initialize LEEWAY WebRTC system
            const initializeWebSocket = React.useCallback(() => {
                console.log('Initializing LEEWAY WebRTC system');

                // Create a new WebRTC client
                const client = new WebSocketClient();

                // Set up event handlers
                client.onConnectionStatusChange((status) => {
                    console.log('Connection status changed:', status);
                    setWsConnected(status === 'connected' || status === 'simulated');

                    if (status === 'connected') {
                        showNotification('LEEWAY WebRTC system initialized', 'success');
                    } else if (status === 'disconnected') {
                        showNotification('WebRTC system disconnected', 'info');
                        setConnectionState('disconnected');

                        // Clean up any ongoing calls
                        if (isCallInProgress) {
                            endCall();
                        }
                    } else if (status === 'peer-failed') {
                        showNotification('WebRTC connection failed. Trying to reconnect...', 'error');
                        setConnectionState('failed');
                    }
                });

                // Set up ICE connection state change handler
                client.onIceConnectionStateChange((userId, state) => {
                    console.log(`ICE connection state for ${userId}: ${state}`);

                    switch (state) {
                        case 'checking':
                            setConnectionState('connecting');
                            break;
                        case 'connected':
                        case 'completed':
                            setConnectionState('connected');
                            break;
                        case 'failed':
                            setConnectionState('failed');
                            showNotification('Connection failed. Check your network settings.', 'error');
                            break;
                        case 'disconnected':
                            setConnectionState('disconnected');
                            showNotification('Connection temporarily disconnected. Attempting to reconnect...', 'warning');
                            break;
                    }
                });

                client.onUserJoined((userId, roomType) => {
                    console.log(`User ${userId} joined the ${roomType} chat`);
                    showNotification(`A family member joined the ${roomType} chat`, 'info');

                    // Set room ID for tracking
                    if (roomType === 'private') {
                        setRoomId(userId);
                    }

                    // If we have a local stream, initiate a call to the new user
                    if (localStream) {
                        console.log('We have a local stream, initiating call to new user');
                        client.initiateCall(userId, localStream);
                    } else {
                        console.log('No local stream available yet');

                        // Try to get the local stream
                        navigator.mediaDevices.getUserMedia({
                            video: {
                                width: { ideal: 640 },
                                height: { ideal: 480 },
                                facingMode: 'user'
                            },
                            audio: true
                        })
                        .then(stream => {
                            console.log('Got local media stream for new user join:', stream.getTracks());
                            setLocalStream(stream);

                            // Set the stream to the local video element
                            const videoElement = document.getElementById('local-video');
                            if (videoElement) {
                                videoElement.srcObject = stream;
                                videoElement.muted = true; // Mute local video to prevent feedback
                                videoElement.play().catch(e => console.error('Error playing local video:', e));
                            }

                            // Add the stream to the WebSocket client and initiate call
                            client.addLocalStream(stream);
                            client.initiateCall(userId, stream);
                        })
                        .catch(error => {
                            console.error('Error accessing camera or microphone for new user join:', error);
                        });
                    }
                });

                client.onTrack((userId, stream) => {
                    console.log('Received remote stream from user:', userId, stream.getTracks());

                    // Add the remote stream to our state
                    setRemoteStreams(prev => ({
                        ...prev,
                        [userId]: stream
                    }));

                    // Set the stream to the remote video element
                    const remoteVideo = document.getElementById('remote-video');
                    if (remoteVideo) {
                        remoteVideo.srcObject = stream;
                        remoteVideo.play().catch(e => console.error('Error playing remote video:', e));
                    }

                    setIsRemoteConnected(true);
                    setCallStatus('connected');
                    showNotification('Video connection established', 'success');
                });

                // Set up speaking detection
                client.onSpeaking((userId, isSpeaking, level) => {
                    console.log(`Speaking detection: ${userId} is ${isSpeaking ? 'speaking' : 'silent'} (level: ${level})`);

                    if (userId === 'local') {
                        setLocalSpeaking(isSpeaking);
                    } else {
                        setRemoteSpeaking(isSpeaking);
                    }

                    // Update audio level for visualization
                    setAudioLevel(level);
                });

                // Initialize the LEEWAY WebRTC system
                client.connect()
                    .then(() => {
                        console.log('LEEWAY WebRTC system initialized successfully');
                        setWsClient(client);
                    })
                    .catch(error => {
                        console.error('Failed to initialize LEEWAY WebRTC system:', error);
                        showNotification('Failed to initialize WebRTC. Please check your browser settings.', 'error');
                    });

                return client;
            }, [localStream, isCallInProgress]);

            // Initialize fake auth state and WebSocket
            React.useEffect(() => {
                // Check for existing fake user in localStorage
                const fakeUserStr = localStorage.getItem('fakeUser');
                if (fakeUserStr) {
                    try {
                        const fakeUser = JSON.parse(fakeUserStr);
                        setUser(fakeUser);
                        setIsAuthenticated(true);

                        // Set online status
                        setUserStatus(true);

                        // Check if user is admin
                        if (fakeUser.displayName && fakeUser.displayName.toLowerCase().includes('admin')) {
                            setIsAdmin(true);
                        }
                    } catch (error) {
                        console.error('Error parsing fake user:', error);
                    }
                }

                // Initialize WebSocket connection
                const client = initializeWebSocket();

                // Set up beforeunload event to update status when user leaves
                window.addEventListener('beforeunload', () => {
                    setUserStatus(false);
                    if (client) {
                        client.disconnect();
                    }
                });

                // Clean up on component unmount
                return () => {
                    setUserStatus(false);
                    if (client) {
                        client.disconnect();
                    }
                };
            }, [initializeWebSocket]);

            // Initialize dark mode from localStorage on component mount
            React.useEffect(() => {
                const savedDarkMode = localStorage.getItem('darkMode') === 'true';
                setDarkMode(savedDarkMode);
                if (savedDarkMode) {
                    document.body.classList.add('dark-mode');
                }
            }, []);

            // Calculate statistics
            const totalAttendees = attendees.reduce((sum, attendee) => sum + attendee.people, 0);
            const uniqueLocations = [...new Set(attendees.map(a => a.location))].filter(Boolean).length;

            return (
                <div className={`min-h-screen ${darkMode ? 'dark-mode' : 'bg-gray-50'}`}>
                    {/* Dark/Light Mode Toggle */}
                    <div className="theme-switch">
                        <label className="switch">
                            <input
                                type="checkbox"
                                onChange={toggleDarkMode}
                                checked={darkMode}
                            />
                            <span className="slider"></span>
                        </label>
                    </div>

                    {/* Balloon Container - keeps balloons at the top */}
                    <div className="balloon-container">
                        {activeBalloons.map(balloon => (
                            <div
                                key={balloon.id}
                                className="balloon"
                                style={{
                                    top: balloon.top,
                                    left: balloon.left,
                                    width: balloon.size,
                                    height: parseInt(balloon.size) * 1.3 + 'px',
                                    backgroundColor: balloon.color,
                                    animationDelay: balloon.delay,
                                    animationDuration: balloon.duration
                                }}
                            />
                        ))}
                    </div>

                    {/* Notification */}
                    {notification && (
                        <div className={`fixed top-5 right-5 p-4 rounded-lg shadow-lg animate__animated animate__fadeIn z-50 ${
                            notification.type === 'success' ? 'bg-green-500 text-white' :
                            notification.type === 'error' ? 'bg-red-500 text-white' :
                            'bg-blue-500 text-white'
                        }`}>
                            <p>{notification.message}</p>
                        </div>
                    )}

                    <div className="container mx-auto px-4 py-8">
                        <div className="text-center mb-12">
                            <div className="family-crest mx-auto mb-4">
                                <svg width="120" height="120" viewBox="0 0 120 120" className="mx-auto">
                                    <defs>
                                        <linearGradient id="crestGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" stopColor="#7a52c7" />
                                            <stop offset="100%" stopColor="#9370DB" />
                                        </linearGradient>
                                    </defs>
                                    <path d="M60,10 L10,40 L10,90 C10,95 15,110 60,110 C105,110 110,95 110,90 L110,40 L60,10 Z"
                                        fill="url(#crestGradient)"
                                        stroke="#5a3a9e"
                                        strokeWidth="2" />
                                    <path d="M60,20 L20,45 L20,85 C20,90 25,100 60,100 C95,100 100,90 100,85 L100,45 L60,20 Z"
                                        fill="none"
                                        stroke="#ffffff"
                                        strokeWidth="1"
                                        strokeDasharray="2" />
                                    <text x="60" y="65"
                                        fontFamily="serif"
                                        fontSize="24"
                                        textAnchor="middle"
                                        fill="#ffffff"
                                        fontWeight="bold">H</text>
                                    <path d="M40,75 L80,75" stroke="#ffffff" strokeWidth="2" />
                                    <path d="M45,85 L75,85" stroke="#ffffff" strokeWidth="1" />
                                    <circle cx="60" cy="50" r="15" fill="none" stroke="#ffffff" strokeWidth="1" />
                                </svg>
                            </div>
                            <h1 className="page-title text-4xl md:text-5xl font-bold text-purple-800 mb-2">Hall Family Reunion</h1>
                            <p className="text-xl text-purple-600">Celebrating Our Family Heritage</p>

                            {/* User Profile Section */}
                            <div className="mt-4 flex justify-center">
                                {isAuthenticated ? (
                                    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-3 flex items-center">
                                        <div className="w-10 h-10 rounded-full bg-purple-600 flex items-center justify-center text-white font-bold mr-3">
                                            {user?.displayName?.charAt(0) || formData.name?.charAt(0) || 'G'}
                                        </div>
                                        <div className="text-left">
                                            <div className="font-medium">
                                                {user?.displayName || formData.name || 'Guest'}
                                                {isAdmin && <span className="ml-2 text-xs bg-purple-100 text-purple-800 px-2 py-1 rounded-full">Admin</span>}
                                            </div>
                                            <div className="text-xs text-gray-500 dark:text-gray-400">
                                                <span className="inline-block w-2 h-2 rounded-full bg-green-500 mr-1"></span> Online
                                            </div>
                                        </div>
                                        <button
                                            onClick={signOut}
                                            className="ml-4 text-xs text-gray-500 hover:text-red-500 dark:text-gray-400 dark:hover:text-red-400"
                                            title="Sign Out"
                                        >
                                            <i className="fas fa-sign-out-alt"></i>
                                        </button>
                                    </div>
                                ) : (
                                    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-3">
                                        <p className="text-sm text-gray-600 dark:text-gray-300">
                                            Sign in by entering your name in the RSVP form
                                        </p>
                                    </div>
                                )}
                            </div>
                        </div>



                        {/* Regular RSVP Card */}
                        <div className="family-card mb-8">
                            <div className="card-header">
                                RSVP
                            </div>
                            <div className="card-body">
                                <form onSubmit={handleAttendSubmit}>
                                    <label className="block text-gray-700 mb-2" htmlFor="name">Name</label>
                                    <input
                                        type="text"
                                        id="name"
                                        name="name"
                                        value={formData.name}
                                        onChange={handleChange}
                                        className="form-input"
                                        placeholder="Your Name"
                                        required
                                    />

                                    <label className="block text-gray-700 mb-2" htmlFor="people">Number Attending</label>
                                    <input
                                        type="number"
                                        id="people"
                                        name="people"
                                        value={formData.people}
                                        onChange={handleChange}
                                        min="1"
                                        max="20"
                                        className="form-input"
                                        required
                                    />

                                    <label className="block text-gray-700 mb-2" htmlFor="location">Location</label>
                                    <input
                                        type="text"
                                        id="location"
                                        name="location"
                                        value={formData.location}
                                        onChange={handleChange}
                                        className="form-input"
                                        placeholder="City, State"
                                        required
                                    />

                                    <button
                                        id="submit-rsvp"
                                        type="submit"
                                        className="submit-btn"
                                    >
                                        Submit
                                    </button>
                                </form>
                            </div>
                        </div>

                        {/* First Row: Message Board and Video Chat */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
                            {/* Message Board Card */}
                            <div className="family-card">
                                <div className="card-header flex justify-between items-center">
                                    <span>Family Message Board</span>
                                    <div className="flex items-center">
                                        <button
                                            onClick={() => setMessageMode('public')}
                                            className={`text-xs py-1 px-2 rounded-l-lg ${messageMode === 'public'
                                                ? 'bg-white text-purple-700'
                                                : 'bg-purple-700 text-white'}`}
                                            title="Public Messages"
                                        >
                                            <i className="fas fa-globe-americas mr-1"></i> Public
                                        </button>
                                        <button
                                            onClick={() => setMessageMode('private')}
                                            className={`text-xs py-1 px-2 rounded-r-lg ${messageMode === 'private'
                                                ? 'bg-white text-purple-700'
                                                : 'bg-purple-700 text-white'}`}
                                            title="Private Messages"
                                        >
                                            <i className="fas fa-user-lock mr-1"></i> Private
                                        </button>
                                    </div>
                                </div>
                                <div className="card-body">
                                    {messageMode === 'public' ? (
                                        /* Public Message Board */
                                        <>
                                            <div className="message-board mb-4">
                                                {messages
                                                    .filter(m => !m.recipient) // Only public messages
                                                    .map((message, index) => (
                                                        <div key={index} className="message-item">
                                                            <div className="message-header">
                                                                <span className="message-sender">{message.sender}</span>
                                                                <span className="message-time">
                                                                    {new Date(message.timestamp).toLocaleString()}
                                                                </span>
                                                            </div>
                                                            <div className="message-content">
                                                                {message.content}
                                                            </div>
                                                        </div>
                                                    ))}
                                                {messages.filter(m => !m.recipient).length === 0 && (
                                                    <div className="text-center py-8 text-gray-500">
                                                        <i className="fas fa-comments text-2xl mb-2"></i>
                                                        <p>No messages yet. Be the first to post!</p>
                                                    </div>
                                                )}
                                            </div>

                                            <div className="flex flex-col">
                                                <input
                                                    type="text"
                                                    id="message"
                                                    name="message"
                                                    value={formData.message}
                                                    onChange={handleChange}
                                                    className="form-input mb-2"
                                                    placeholder="Share a message with the family..."
                                                />

                                                {/* Emoji Picker */}
                                                <div className="emoji-picker mb-3 p-2 bg-gray-100 dark:bg-gray-800 rounded-lg overflow-x-auto whitespace-nowrap">
                                                    {commonEmojis.map((emoji, index) => (
                                                        <button
                                                            key={index}
                                                            onClick={() => addEmojiToMessage(emoji)}
                                                            className="emoji-btn inline-block mx-1 text-xl hover:transform hover:scale-125 transition-transform"
                                                            title={`Add ${emoji} emoji`}
                                                        >
                                                            {emoji}
                                                        </button>
                                                    ))}
                                                </div>

                                                <div className="flex gap-2">
                                                    <button
                                                        id="send-message"
                                                        onClick={handleMessageSubmit}
                                                        className="submit-btn flex-grow"
                                                    >
                                                        Post Message
                                                    </button>

                                                    <button
                                                        onClick={startListening}
                                                        className="bg-purple-600 hover:bg-purple-700 text-white rounded-lg p-3 flex items-center justify-center"
                                                        title="Voice Input"
                                                    >
                                                        <i className="fas fa-microphone"></i>
                                                    </button>
                                                </div>
                                            </div>
                                        </>
                                    ) : (
                                        /* Private Message Interface */
                                        <>
                                            <div className="mb-4">
                                                <div className="flex items-center mb-3">
                                                    <div className="text-sm font-semibold mr-2">Select Recipient:</div>
                                                    <select
                                                        className="form-input text-sm py-1 flex-grow"
                                                        value={privateMessageRecipient}
                                                        onChange={(e) => setPrivateMessageRecipient(e.target.value)}
                                                    >
                                                        <option value="">-- Select Family Member --</option>
                                                        {attendees.map((attendee, index) => (
                                                            <option key={index} value={attendee.name}>
                                                                {attendee.name} ({attendee.location})
                                                            </option>
                                                        ))}
                                                    </select>
                                                </div>

                                                <div className="message-board mb-4">
                                                    {privateMessageRecipient ? (
                                                        <>
                                                            {messages
                                                                .filter(m =>
                                                                    (m.sender === formData.name && m.recipient === privateMessageRecipient) ||
                                                                    (m.sender === privateMessageRecipient && m.recipient === formData.name)
                                                                )
                                                                .map((message, index) => (
                                                                    <div
                                                                        key={index}
                                                                        className={`message-item ${message.sender === formData.name ? 'bg-purple-50' : 'bg-gray-50'}`}
                                                                    >
                                                                        <div className="message-header">
                                                                            <span className="message-sender">
                                                                                {message.sender === formData.name ? 'You' : message.sender}
                                                                            </span>
                                                                            <span className="message-time">
                                                                                {new Date(message.timestamp).toLocaleString()}
                                                                            </span>
                                                                        </div>
                                                                        <div className="message-content">
                                                                            {message.content}
                                                                        </div>
                                                                    </div>
                                                                ))}
                                                            {messages.filter(m =>
                                                                (m.sender === formData.name && m.recipient === privateMessageRecipient) ||
                                                                (m.sender === privateMessageRecipient && m.recipient === formData.name)
                                                            ).length === 0 && (
                                                                <div className="text-center py-8 text-gray-500">
                                                                    <i className="fas fa-envelope text-2xl mb-2"></i>
                                                                    <p>No messages yet with {privateMessageRecipient}.</p>
                                                                </div>
                                                            )}
                                                        </>
                                                    ) : (
                                                        <div className="text-center py-8 text-gray-500">
                                                            <i className="fas fa-user-friends text-2xl mb-2"></i>
                                                            <p>Select a family member to see your conversation.</p>
                                                        </div>
                                                    )}
                                                </div>

                                                {privateMessageRecipient && (
                                                    <div className="flex flex-col">
                                                        <div className="flex items-center mb-2">
                                                            <div className="text-sm font-semibold mr-2">Messaging:</div>
                                                            <div className="text-purple-600 font-medium">{privateMessageRecipient}</div>
                                                        </div>

                                                        <input
                                                            type="text"
                                                            id="private-message"
                                                            name="privateMessage"
                                                            value={formData.privateMessage}
                                                            onChange={handleChange}
                                                            className="form-input mb-2"
                                                            placeholder={`Send a private message to ${privateMessageRecipient}...`}
                                                        />

                                                        {/* Emoji Picker */}
                                                        <div className="emoji-picker mb-3 p-2 bg-gray-100 dark:bg-gray-800 rounded-lg overflow-x-auto whitespace-nowrap">
                                                            {commonEmojis.map((emoji, index) => (
                                                                <button
                                                                    key={index}
                                                                    onClick={() => addEmojiToPrivateMessage(emoji)}
                                                                    className="emoji-btn inline-block mx-1 text-xl hover:transform hover:scale-125 transition-transform"
                                                                    title={`Add ${emoji} emoji`}
                                                                >
                                                                    {emoji}
                                                                </button>
                                                            ))}
                                                        </div>

                                                        <div className="flex gap-2">
                                                            <button
                                                                onClick={handlePrivateMessageSubmit}
                                                                className="bg-indigo-600 hover:bg-indigo-700 text-white py-2 px-4 rounded-lg flex-grow flex items-center justify-center"
                                                            >
                                                                <i className="fas fa-paper-plane mr-2"></i>
                                                                Send Private Message
                                                            </button>

                                                            <button
                                                                onClick={() => startListening('private')}
                                                                className="bg-purple-600 hover:bg-purple-700 text-white rounded-lg p-3 flex items-center justify-center"
                                                                title="Voice Input for Private Message"
                                                            >
                                                                <i className="fas fa-microphone"></i>
                                                            </button>
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        </>
                                    )}
                                </div>
                            </div>

                            {/* Video Chat Card */}
                            <div className="family-card">
                                <div className="card-header flex justify-between items-center">
                                    <span>Video & Voice Chat</span>
                                    {/* WebSocket connection status indicator */}
                                    {wsConnected ? (
                                        <span className="text-xs bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 px-2 py-1 rounded-full flex items-center">
                                            <span className="w-2 h-2 bg-green-500 rounded-full mr-1"></span>
                                            LEEWAY Ready
                                        </span>
                                    ) : (
                                        <span className="text-xs bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200 px-2 py-1 rounded-full flex items-center">
                                            <span className="w-2 h-2 bg-yellow-500 rounded-full mr-1"></span>
                                            Initializing
                                        </span>
                                    )}
                                </div>
                                <div className="card-body">
                                    {showVideoChat ? (
                                        <div>
                                            <div className="mb-4">
                                                {/* Main video display - Remote video takes precedence when connected */}
                                                <div className="relative mb-3" style={{ height: '180px' }}>
                                                    <div className="relative">
                                                        <video
                                                            id="remote-video"
                                                            autoPlay
                                                            playsInline
                                                            className={`w-full h-full object-cover rounded-lg bg-gray-200 border-2 ${remoteSpeaking ? 'border-green-500' : 'border-purple-300'}`}
                                                        ></video>
                                                        {remoteSpeaking && (
                                                            <div className="absolute top-2 right-2 bg-green-500 text-white text-xs px-2 py-1 rounded-full flex items-center">
                                                                <i className="fas fa-microphone mr-1"></i> Speaking
                                                            </div>
                                                        )}
                                                    </div>

                                                    {/* WebRTC Connection Status Indicator */}
                                                    <div className={`video-status ${
                                                        connectionState === 'connected' ? 'bg-green-500' :
                                                        connectionState === 'connecting' ? 'bg-yellow-500' :
                                                        connectionState === 'failed' ? 'bg-red-500' : 'bg-gray-500'
                                                    }`}>
                                                        {connectionState === 'connected' && (
                                                            <span><i className="fas fa-signal"></i> Connected</span>
                                                        )}
                                                        {connectionState === 'connecting' && (
                                                            <span><i className="fas fa-spinner fa-spin"></i> Connecting...</span>
                                                        )}
                                                        {connectionState === 'failed' && (
                                                            <span><i className="fas fa-exclamation-triangle"></i> Connection Failed</span>
                                                        )}
                                                        {connectionState === 'disconnected' && (
                                                            <span><i className="fas fa-plug"></i> Disconnected</span>
                                                        )}
                                                    </div>

                                                    {!isRemoteConnected && (
                                                        <div className="absolute inset-0 flex items-center justify-center text-gray-500">
                                                            <div className="text-center">
                                                                {callStatus === 'dialing' ? (
                                                                    <>
                                                                        <i className="fas fa-circle-notch fa-spin text-3xl mb-2 text-blue-500"></i>
                                                                        <div className="text-sm text-blue-500">Calling...</div>
                                                                    </>
                                                                ) : callStatus === 'ringing' ? (
                                                                    <>
                                                                        <i className="fas fa-phone-volume text-3xl mb-2 text-yellow-500"></i>
                                                                        <div className="text-sm text-yellow-500">Ringing...</div>
                                                                    </>
                                                                ) : (
                                                                    <>
                                                                        <i className="fas fa-user-slash text-3xl mb-2"></i>
                                                                        <div className="text-sm">No one connected</div>
                                                                        <div className="text-xs text-gray-400 mt-1">Select a family member and click the call button</div>
                                                                    </>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}

                                                    {/* Picture-in-picture local video */}
                                                    <div className="absolute bottom-2 right-2 w-1/4 h-1/4 min-w-[80px] min-h-[60px] relative">
                                                        <video
                                                            id="local-video"
                                                            autoPlay
                                                            muted
                                                            playsInline
                                                            className={`w-full h-full object-cover rounded-lg border ${localSpeaking ? 'border-green-500' : 'border-white'} shadow-md`}
                                                        ></video>

                                                        {/* Local video status indicators */}
                                                        <div className="absolute top-0 left-0 bg-blue-500 text-white text-xs px-1 py-0.5 rounded-br">
                                                            {isCameraOff ? 'Off' : 'You'}
                                                        </div>

                                                        {/* Speaking indicator */}
                                                        {localSpeaking && (
                                                            <div className="absolute top-0 right-0 bg-green-500 text-white text-xs px-1 py-0.5 rounded-bl">
                                                                <i className="fas fa-microphone text-xs"></i>
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>

                                                {/* Video labels */}
                                                <div className="flex justify-between text-xs text-gray-600 px-1">
                                                    <div>
                                                        <i className="fas fa-user mr-1"></i> Remote: {selectedMember || "Not selected"}
                                                    </div>
                                                    <div>
                                                        <i className="fas fa-user mr-1"></i> You: {formData.name || "Guest"}
                                                    </div>
                                                </div>
                                            </div>

                                            <div className="grid grid-cols-2 gap-2 mb-4">
                                                <div className="text-center">
                                                    <div className="text-sm font-semibold mb-1">Chat Type</div>
                                                    <div className="flex">
                                                        <button
                                                            onClick={() => setChatType('group')}
                                                            className={`flex-1 py-1 px-2 text-xs rounded-l-lg ${chatType === 'group'
                                                                ? 'bg-purple-600 text-white'
                                                                : 'bg-gray-200 text-gray-700'}`}
                                                        >
                                                            Group
                                                        </button>
                                                        <button
                                                            onClick={() => setChatType('private')}
                                                            className={`flex-1 py-1 px-2 text-xs rounded-r-lg ${chatType === 'private'
                                                                ? 'bg-purple-600 text-white'
                                                                : 'bg-gray-200 text-gray-700'}`}
                                                        >
                                                            Private
                                                        </button>
                                                    </div>
                                                </div>

                                                {chatType === 'private' && (
                                                    <div>
                                                        <div className="text-sm font-semibold mb-1">Select Member</div>
                                                        <div className="flex gap-2">
                                                            <select
                                                                className="form-input text-sm py-1 flex-grow"
                                                                value={selectedMember}
                                                                onChange={(e) => setSelectedMember(e.target.value)}
                                                                disabled={isCallInProgress}
                                                            >
                                                                <option value="">-- Select --</option>
                                                                {attendees.map((attendee, index) => (
                                                                    <option key={index} value={attendee.name}>
                                                                        {attendee.name} ({attendee.location})
                                                                    </option>
                                                                ))}
                                                            </select>

                                                            {!isCallInProgress ? (
                                                                <button
                                                                    onClick={handleCallButtonClick}
                                                                    className="bg-green-500 hover:bg-green-600 text-white rounded-lg px-3 flex items-center justify-center"
                                                                    disabled={!selectedMember}
                                                                    title="Call this person"
                                                                >
                                                                    <i className="fas fa-phone-alt"></i>
                                                                </button>
                                                            ) : (
                                                                <button
                                                                    onClick={endCall}
                                                                    className="bg-red-500 hover:bg-red-600 text-white rounded-lg px-3 flex items-center justify-center"
                                                                    title="End call"
                                                                >
                                                                    <i className="fas fa-phone-slash"></i>
                                                                </button>
                                                            )}
                                                        </div>

                                                        {/* Call status indicator */}
                                                        {callStatus && (
                                                            <div className="mt-2 text-xs">
                                                                {callStatus === 'dialing' && (
                                                                    <div className="text-blue-500">
                                                                        <i className="fas fa-circle-notch fa-spin mr-1"></i> Dialing...
                                                                    </div>
                                                                )}
                                                                {callStatus === 'ringing' && (
                                                                    <div className="text-yellow-500">
                                                                        <i className="fas fa-phone-volume mr-1"></i> Ringing...
                                                                    </div>
                                                                )}
                                                                {callStatus === 'connected' && (
                                                                    <div className="text-green-500">
                                                                        <i className="fas fa-phone mr-1"></i> Connected
                                                                    </div>
                                                                )}
                                                                {callStatus === 'ended' && (
                                                                    <div className="text-red-500">
                                                                        <i className="fas fa-phone-slash mr-1"></i> Call ended
                                                                    </div>
                                                                )}
                                                            </div>
                                                        )}
                                                    </div>
                                                )}
                                            </div>

                                            <div className="flex gap-2 mb-4">
                                                <button
                                                    onClick={toggleMicrophone}
                                                    className={`flex-1 py-2 rounded-lg flex items-center justify-center ${isMicMuted
                                                        ? 'bg-gray-300 text-gray-700'
                                                        : 'bg-green-500 text-white'}`}
                                                >
                                                    <i className={`fas ${isMicMuted ? 'fa-microphone-slash' : 'fa-microphone'} mr-2`}></i>
                                                    {isMicMuted ? 'Unmute' : 'Mute'}
                                                </button>

                                                <button
                                                    onClick={toggleCamera}
                                                    className={`flex-1 py-2 rounded-lg flex items-center justify-center ${isCameraOff
                                                        ? 'bg-gray-300 text-gray-700'
                                                        : 'bg-green-500 text-white'}`}
                                                >
                                                    <i className={`fas ${isCameraOff ? 'fa-video-slash' : 'fa-video'} mr-2`}></i>
                                                    {isCameraOff ? 'Show Camera' : 'Hide Camera'}
                                                </button>
                                            </div>

                                            {chatType === 'private' && (
                                                <div className="mb-4">
                                                    <div className="text-sm font-semibold mb-1">Push-to-Talk</div>
                                                    <button
                                                        onMouseDown={startPushToTalk}
                                                        onMouseUp={stopPushToTalk}
                                                        onMouseLeave={stopPushToTalk}
                                                        onTouchStart={startPushToTalk}
                                                        onTouchEnd={stopPushToTalk}
                                                        className="bg-yellow-500 hover:bg-yellow-600 text-white py-3 px-4 rounded-lg w-full flex items-center justify-center"
                                                    >
                                                        <i className="fas fa-bullhorn mr-2"></i>
                                                        Press & Hold to Talk
                                                    </button>
                                                </div>
                                            )}

                                            <button
                                                onClick={stopVideoChat}
                                                className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg w-full"
                                            >
                                                End Chat Session
                                            </button>
                                        </div>
                                    ) : (
                                        <div className="text-center py-6">
                                            <p className="mb-4">Connect with family members</p>

                                            {/* Pre-call test button */}
                                            <button
                                                onClick={() => testMediaDevices()}
                                                className="bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg mb-4 flex items-center mx-auto"
                                            >
                                                <i className="fas fa-video-slash mr-2"></i>
                                                Test Camera & Microphone
                                            </button>

                                            <div className="grid grid-cols-2 gap-4">
                                                <button
                                                    onClick={() => startVideoChat('group')}
                                                    className="bg-purple-600 hover:bg-purple-700 text-white py-3 px-4 rounded-lg flex flex-col items-center"
                                                >
                                                    <i className="fas fa-users text-2xl mb-2"></i>
                                                    Group Video Chat
                                                </button>

                                                <button
                                                    onClick={() => startVideoChat('private')}
                                                    className="bg-indigo-600 hover:bg-indigo-700 text-white py-3 px-4 rounded-lg flex flex-col items-center"
                                                >
                                                    <i className="fas fa-user-friends text-2xl mb-2"></i>
                                                    Private Video Chat
                                                </button>

                                                <button
                                                    onClick={() => startVideoChat('audio')}
                                                    className="bg-green-600 hover:bg-green-700 text-white py-3 px-4 rounded-lg flex flex-col items-center"
                                                >
                                                    <i className="fas fa-phone-alt text-2xl mb-2"></i>
                                                    Voice Only Chat
                                                </button>

                                                <button
                                                    onClick={() => startVideoChat('cb')}
                                                    className="bg-yellow-600 hover:bg-yellow-700 text-white py-3 px-4 rounded-lg flex flex-col items-center"
                                                >
                                                    <i className="fas fa-bullhorn text-2xl mb-2"></i>
                                                    CB-Style Talk
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* Second Row: RSVP List and Suggestions */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                            {/* RSVP List Card */}
                            <div className="family-card">
                                <div className="card-header flex justify-between items-center">
                                    <span>RSVP List</span>
                                    {isAdmin && (
                                        <button
                                            onClick={clearAttendeeList}
                                            className="bg-red-500 hover:bg-red-600 text-white text-xs py-1 px-2 rounded"
                                            title="Admin: Clear RSVP List"
                                        >
                                            <i className="fas fa-trash-alt mr-1"></i> Clear List
                                        </button>
                                    )}
                                </div>
                                <div className="card-body">
                                    <div className="mb-4">
                                        <div className="text-lg font-semibold mb-2">Total Attendees: {attendees.reduce((sum, a) => sum + a.people, 0)}</div>
                                        <div className="text-sm text-gray-600 mb-4">From {[...new Set(attendees.map(a => a.location))].filter(Boolean).length} different locations</div>
                                    </div>

                                    <div className="overflow-y-auto" style={{ maxHeight: "300px" }}>
                                        {attendees.length === 0 ? (
                                            <p className="text-gray-500 italic">No one has RSVP'd yet.</p>
                                        ) : (
                                            <ul className="divide-y divide-gray-200">
                                                {attendees.map((attendee, index) => (
                                                    <li key={index} className="py-3">
                                                        <div className="font-medium">{attendee.name}</div>
                                                        <div className="text-sm text-gray-600">
                                                            {attendee.people} {attendee.people === 1 ? 'person' : 'people'} from {attendee.location}
                                                        </div>
                                                        <div className="text-xs text-gray-500">
                                                            {new Date(attendee.timestamp).toLocaleDateString()}
                                                        </div>
                                                        {isAdmin && (
                                                            <button
                                                                onClick={() => removeAttendee(attendee.id)}
                                                                className="text-red-500 hover:text-red-700 text-xs mt-1"
                                                                title="Remove this attendee"
                                                            >
                                                                <i className="fas fa-times mr-1"></i> Remove
                                                            </button>
                                                        )}
                                                    </li>
                                                ))}
                                            </ul>
                                        )}
                                    </div>
                                </div>
                            </div>

                            {/* Suggestions Card with Activity Popularity */}
                            <div className="family-card">
                                <div className="card-header">
                                    Activity Suggestions
                                </div>
                                <div className="card-body">
                                    {/* Activity Popularity Section */}
                                    <div className="mb-6">
                                        <h3 className="text-lg font-semibold mb-3">Activity Popularity</h3>
                                        <div className="text-sm text-gray-600 mb-2">Total votes: {activities.reduce((sum, a) => sum + a.votes, 0)}</div>

                                        {activities
                                            .sort((a, b) => b.votes - a.votes)
                                            .slice(0, 5)
                                            .map((activity, index) => {
                                                const maxVotes = Math.max(...activities.map(a => a.votes));
                                                const percentage = maxVotes > 0 ? (activity.votes / maxVotes) * 100 : 0;

                                                return (
                                                    <div key={activity.id} className="tally-item">
                                                        <div className="tally-name">{activity.title}</div>
                                                        <div className="tally-bar-container">
                                                            <div
                                                                className="tally-bar"
                                                                style={{ width: `${percentage}%` }}
                                                            ></div>
                                                        </div>
                                                        <div className="tally-count">{activity.votes}</div>
                                                    </div>
                                                );
                                            })
                                        }
                                    </div>

                                    {/* Activity List Section */}
                                    <h3 className="text-lg font-semibold mb-3">All Activities</h3>
                                    <ul className="suggestion-list mb-4 max-h-40 overflow-y-auto">
                                        {activities.map(activity => (
                                            <li key={activity.id} className="flex justify-between items-center py-1">
                                                <div className="flex-grow">
                                                    <span>{activity.title}</span>
                                                    <span className="text-xs text-gray-500 ml-2">
                                                        by {activity.submitter || 'Anonymous'}
                                                    </span>
                                                </div>
                                                <div className="flex items-center">
                                                    <span className="text-xs text-gray-500 mr-2">
                                                        {activity.votes} {activity.votes === 1 ? 'vote' : 'votes'}
                                                    </span>
                                                    <button
                                                        onClick={() => handleVote('activity', activity.id)}
                                                        className="text-purple-600 hover:text-purple-800 text-xs"
                                                        title="Vote for this activity"
                                                    >
                                                        <i className="fas fa-thumbs-up"></i>
                                                    </button>
                                                    {isAdmin && (
                                                        <button
                                                            onClick={() => removeActivity(activity.id)}
                                                            className="text-red-500 hover:text-red-700 text-xs ml-2"
                                                            title="Remove this activity"
                                                        >
                                                            <i className="fas fa-times"></i>
                                                        </button>
                                                    )}
                                                </div>
                                            </li>
                                        ))}
                                    </ul>

                                    {/* Add New Activity Section */}
                                    <div className="mt-4">
                                        <label className="block text-gray-700 mb-2" htmlFor="activity-dropdown">
                                            Select or add a new activity:
                                        </label>

                                        {/* Activity Dropdown */}
                                        <div className="mb-3">
                                            <div className="flex gap-2">
                                                <select
                                                    id="activity-dropdown"
                                                    className="form-input flex-grow"
                                                    onChange={(e) => {
                                                        const selectedIndex = e.target.value;
                                                        if (selectedIndex !== "") {
                                                            // Get the selected activity
                                                            const activity = activitySuggestions[parseInt(selectedIndex)];
                                                            if (activity) {
                                                                handleActivitySelect(activity);
                                                            }
                                                        } else {
                                                            // Clear the form if "Select an activity" is chosen
                                                            setFormData(prev => ({ ...prev, activity: '', activityDesc: '' }));
                                                        }
                                                    }}
                                                >
                                                    <option value="">-- Select an activity --</option>
                                                    <optgroup label="Backyard Games">
                                                        {activitySuggestions
                                                            .filter(a => a.category === "Backyard Games")
                                                            .map((activity, index) => (
                                                                <option key={index} value={index}>
                                                                    {activity.name}
                                                                </option>
                                                            ))
                                                        }
                                                    </optgroup>
                                                    <optgroup label="Board & Card Games">
                                                        {activitySuggestions
                                                            .filter(a => a.category === "Board & Card Games")
                                                            .map((activity, index) => (
                                                                <option key={index + 10} value={index + 10}>
                                                                    {activity.name}
                                                                </option>
                                                            ))
                                                        }
                                                    </optgroup>
                                                </select>
                                                <button
                                                    onClick={() => {
                                                        // Clear the activity input
                                                        setFormData(prev => ({ ...prev, activity: '', activityDesc: '' }));
                                                        // Reset dropdown
                                                        document.getElementById('activity-dropdown').value = '';
                                                        // Show notification
                                                        showNotification('Selection cleared', 'info');
                                                    }}
                                                    className="bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-lg px-3"
                                                    title="Clear selection"
                                                    type="button"
                                                >
                                                    <i className="fas fa-times"></i>
                                                </button>
                                            </div>
                                            <div className="text-xs text-gray-500 mt-1">
                                                Select an activity from the list or type your own below
                                            </div>
                                        </div>

                                        {/* Custom Activity Input */}
                                        <div className="flex gap-2">
                                            <div className="relative flex-grow">
                                                <input
                                                    type="text"
                                                    id="add-suggestion"
                                                    name="activity"
                                                    value={formData.activity}
                                                    onChange={handleChange}
                                                    className="form-input w-full pr-10"
                                                    placeholder="Or type your own activity..."
                                                />
                                                {formData.activity && (
                                                    <button
                                                        onClick={() => {
                                                            // Clear the activity input
                                                            setFormData(prev => ({ ...prev, activity: '', activityDesc: '' }));
                                                            // Reset dropdown
                                                            document.getElementById('activity-dropdown').value = '';
                                                            // Focus back on the input
                                                            document.getElementById('add-suggestion').focus();
                                                        }}
                                                        className="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-red-500"
                                                        title="Clear selection"
                                                        type="button"
                                                    >
                                                        <i className="fas fa-times"></i>
                                                    </button>
                                                )}
                                            </div>
                                            <button
                                                onClick={handleActivitySubmit}
                                                className="bg-purple-600 hover:bg-purple-700 text-white rounded-lg px-4 py-2"
                                            >
                                                Add
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>



                        {/* SMS Notification Info */}
                        <div className="mt-8 text-center text-sm text-gray-500">
                            <p>Admin notifications will be sent to: (414) 367-6211</p>
                        </div>

                        {/* Stop Speaking Button */}
                        {isSpeaking && (
                            <div className="fixed bottom-5 right-5 z-50">
                                <button
                                    onClick={stopSpeaking}
                                    className="bg-red-500 hover:bg-red-600 text-white rounded-full p-3 w-12 h-12 flex items-center justify-center shadow-lg"
                                    title="Stop Talking"
                                >
                                    <i className="fas fa-stop"></i>
                                </button>
                            </div>
                        )}

                        {/* Speech Output Display */}
                        {speechOutput && (
                            <div className="fixed bottom-5 left-5 z-50 bg-white p-3 rounded-lg shadow-lg max-w-xs">
                                <div className="text-sm font-medium">Voice Input:</div>
                                <div className="text-gray-700">{speechOutput}</div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        // Render the app
        ReactDOM.render(<App />, document.getElementById('app'));
    </script>
    <!-- ðŸ§  END REGION: AI & MAIN APP CODE -->

    <!-- Mobile-specific styles -->
    <style>
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .form-input, .submit-btn, button {
                /* Increase touch target size */
                min-height: 44px;
                font-size: 16px; /* Prevent iOS zoom on focus */
            }

            /* Improve spacing on mobile */
            .card-body {
                padding: 15px 10px;
            }

            /* Make buttons easier to tap */
            .video-control-btn {
                width: 44px;
                height: 44px;
                margin: 0 5px;
            }

            /* Adjust push-to-talk button for mobile */
            button[onmousedown], button[ontouchstart] {
                padding: 15px !important;
                font-size: 18px !important;
            }

            /* Improve microphone button visibility */
            button[title="Voice Input"],
            button[title="Voice Input for Private Message"] {
                width: 44px;
                height: 44px;
            }

            /* Fix video sizing on mobile */
            #local-video, #remote-video {
                max-height: 30vh;
                width: 100%;
                object-fit: cover;
            }

            /* Adjust for mobile landscape mode */
            @media (orientation: landscape) {
                #local-video, #remote-video {
                    max-height: 50vh;
                }

                .video-container {
                    max-height: 50vh;
                }
            }

            /* Fix for iOS Safari 100vh issue */
            .min-h-screen {
                min-height: -webkit-fill-available;
            }

            /* Improve mobile dark mode */
            .dark-mode .form-input,
            .dark-mode button,
            .dark-mode .submit-btn {
                font-size: 16px;
            }

            /* Fix for mobile keyboards */
            input, textarea, select {
                font-size: 16px !important; /* Prevent zoom on iOS */
            }
        }

        /* Fix for mobile Safari audio issues */
        .mobile-device audio {
            visibility: hidden;
            position: absolute;
            height: 1px;
            width: 1px;
            opacity: 0.01;
        }

        /* Improve mobile push-to-talk feedback */
        .push-to-talk-active {
            background-color: #e11d48 !important; /* Bright red when active */
            transform: scale(0.95);
            transition: all 0.1s ease-in-out;
        }
    </style>

    <!-- Mobile optimization script -->
    <script>
        // Handle device orientation changes
        window.addEventListener('orientationchange', () => {
            console.log('Orientation changed to:', window.orientation);

            // Give the browser time to adjust
            setTimeout(() => {
                // Adjust video elements if they exist
                const videoElements = document.querySelectorAll('video');
                videoElements.forEach(video => {
                    // Reset any transforms first
                    video.style.transform = '';

                    // Force layout recalculation
                    video.getBoundingClientRect();

                    // Apply appropriate sizing
                    if (window.orientation === 90 || window.orientation === -90) {
                        // Landscape mode
                        console.log('Adjusting video for landscape mode');
                        video.style.maxHeight = '50vh';
                    } else {
                        // Portrait mode
                        console.log('Adjusting video for portrait mode');
                        video.style.maxHeight = '30vh';
                    }
                });

                // Force redraw of the page
                document.body.style.display = 'none';
                document.body.offsetHeight; // Force reflow
                document.body.style.display = '';
            }, 300);
        });

        // Check for mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            console.log('Mobile device detected, applying mobile optimizations');

            // Add mobile-specific class to body
            document.body.classList.add('mobile-device');

            // Add passive event listeners for better scroll performance
            document.addEventListener('touchstart', function() {}, {passive: true});
            document.addEventListener('touchmove', function() {}, {passive: true});

            // Fix for iOS audio context issues
            function unlockAudioContext() {
                console.log('Attempting to unlock audio context');
                // Create a temporary audio context
                const tempContext = new (window.AudioContext || window.webkitAudioContext)();

                // Create a buffer source
                const source = tempContext.createBufferSource();
                source.buffer = tempContext.createBuffer(1, 1, 22050);
                source.connect(tempContext.destination);

                // Play the source (required for iOS)
                source.start(0);

                // Clean up
                setTimeout(() => {
                    if (tempContext.state === 'running') {
                        console.log('Audio context unlocked successfully');
                    }
                    tempContext.close();
                }, 100);
            }

            // Unlock audio on first user interaction
            const unlockAudio = () => {
                unlockAudioContext();

                // Remove event listeners once unlocked
                document.removeEventListener('touchstart', unlockAudio);
                document.removeEventListener('touchend', unlockAudio);
                document.removeEventListener('click', unlockAudio);
            };

            document.addEventListener('touchstart', unlockAudio);
            document.addEventListener('touchend', unlockAudio);
            document.addEventListener('click', unlockAudio);

            // Fix for push-to-talk on mobile
            const fixPushToTalkButtons = () => {
                const pushToTalkButtons = document.querySelectorAll('[onmousedown], [ontouchstart]');
                pushToTalkButtons.forEach(button => {
                    // Add active class when pressed
                    button.addEventListener('touchstart', () => {
                        button.classList.add('push-to-talk-active');
                    });

                    // Remove active class when released
                    button.addEventListener('touchend', () => {
                        button.classList.remove('push-to-talk-active');
                    });

                    // Remove active class when touch is canceled
                    button.addEventListener('touchcancel', () => {
                        button.classList.remove('push-to-talk-active');
                    });
                });
            };

            // Run the fix when DOM is loaded
            document.addEventListener('DOMContentLoaded', fixPushToTalkButtons);

            // Also run it after a short delay to catch dynamically added buttons
            setTimeout(fixPushToTalkButtons, 2000);
        }
    </script>
</body>
</html>